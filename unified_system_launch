#!/usr/bin/env python3
"""
UNIFIED SYSTEM LAUNCHER - Tank Level Control System
Intelligent launcher that automatically handles all integration scenarios
"""

import subprocess
import threading
import time
import signal
import sys
import os
import logging
from pathlib import Path
import importlib.util

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - [LAUNCHER] - %(message)s'
)
logger = logging.getLogger(__name__)

class UnifiedLauncher:
    """Intelligent system launcher with automatic dependency detection and fallbacks."""
    
    def __init__(self):
        self.processes = {}
        self.running = True
        self.dependencies_checked = False
        self.available_components = {}
        
        # Setup signal handlers
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
        
        # Check system capabilities
        self.check_system_capabilities()
    
    def signal_handler(self, signum, frame):
        """Handle shutdown signals."""
        logger.info(f"Received signal {signum}, shutting down all components...")
        self.shutdown_all()
        sys.exit(0)
    
    def check_system_capabilities(self):
        """Check what components can run on this system."""
        print("\n" + "=" * 60)
        print("TANK LEVEL CONTROL SYSTEM - UNIFIED LAUNCHER")
        print("=" * 60)
        print("Checking system capabilities...")
        
        # Check Python version
        python_version = sys.version_info
        if python_version.major >= 3 and python_version.minor >= 8:
            print(f"✓ Python {python_version.major}.{python_version.minor} - Compatible")
        else:
            print(f"⚠ Python {python_version.major}.{python_version.minor} - May have issues")
        
        # Check required files
        self.check_files()
        
        # Check dependencies
        self.check_dependencies()
        
        # Show recommendations
        self.show_recommendations()
    
    def check_files(self):
        """Check for required files."""
        required_files = {
            'standalone_hmi.py': 'Standalone HMI (Air-gapped)',
            'enhanced_hmi.py': 'Enhanced HMI (PyModbus)',
            'app.py': 'Web HMI (Flask)',
            'harmony_hmi_desktop.py': 'Desktop HMI (Tkinter)',
            'config.py': 'System Configuration',
            'arduino_plc_controller.ino': 'Arduino PLC Code'
        }
        
        print("\nChecking system files:")
        for file, description in required_files.items():
            if Path(file).exists():
                self.available_components[file] = True
                print(f"✓ {file:<25} - {description}")
            else:
                self.available_components[file] = False
                print(f"✗ {file:<25} - Missing ({description})")
    
    def check_dependencies(self):
        """Check for optional dependencies."""
        dependencies = {
            'flask': 'Web interface support',
            'pymodbus': 'Enhanced Modbus communication',
            'requests': 'HTTP communication',
            'tkinter': 'Desktop GUI support'
        }
        
        print("\nChecking optional dependencies:")
        self.available_components['dependencies'] = {}
        
        for dep, description in dependencies.items():
            try:
                if dep == 'tkinter':
                    import tkinter
                else:
                    __import__(dep)
                self.available_components['dependencies'][dep] = True
                print(f"✓ {dep:<15} - {description}")
            except ImportError:
                self.available_components['dependencies'][dep] = False
                print(f"✗ {dep:<15} - Not available ({description})")
        
        self.dependencies_checked = True
    
    def show_recommendations(self):
        """Show system recommendations based on capabilities."""
        print("\n" + "=" * 60)
        print("SYSTEM RECOMMENDATIONS")
        print("=" * 60)
        
        # Determine best option
        if self.available_components.get('standalone_hmi.py', False):
            print("🎯 RECOMMENDED: Standalone HMI")
            print("   • Works on any system (no dependencies required)")
            print("   • Perfect for air-gapped industrial environments")
            print("   • Built-in Modbus TCP client")
            print("   • Command: python standalone_hmi.py")
            print()
        
        if (self.available_components.get('enhanced_hmi.py', False) and 
            self.available_components['dependencies'].get('pymodbus', False)):
            print("🚀 ENHANCED: Enhanced HMI with PyModbus")
            print("   • Advanced features and diagnostics")
            print("   • Professional data logging and trends")
            print("   • Comprehensive error handling")
            print("   • Command: python enhanced_hmi_fixed.py")
            print()
        
        if (self.available_components.get('app.py', False) and 
            self.available_components['dependencies'].get('flask', False)):
            print("🌐 WEB INTERFACE: Flask Web HMI")
            print("   • Browser-based interface")
            print("   • Remote access capability")
            print("   • Modern web UI with diagnostics")
            print("   • Command: python app.py")
            print()
        
        if (self.available_components.get('harmony_hmi_desktop.py', False) and 
            self.available_components['dependencies'].get('tkinter', False)):
            print("🖥️ DESKTOP: Desktop HMI")
            print("   • Native desktop application")
            print("   • Real-time monitoring")
            print("   • Integration with web services")
            print("   • Command: python harmony_hmi_desktop.py")
            print()
        
        # Show missing dependencies if any
        missing_deps = [dep for dep, available in self.available_components['dependencies'].items() if not available]
        if missing_deps:
            print("📦 To install missing dependencies:")
            print(f"   pip install {' '.join(missing_deps)}")
            print()
    
    def show_main_menu(self):
        """Show the main launcher menu."""
        while True:
            print("\n" + "=" * 60)
            print("TANK LEVEL CONTROL SYSTEM - LAUNCH OPTIONS")
            print("=" * 60)
            
            options = []
            
            # Option 1: Standalone HMI (always first if available)
            if self.available_components.get('standalone_hmi.py', False):
                options.append(('Standalone HMI (Recommended - No Dependencies)', 'standalone'))
                print(f"{len(options)}. Standalone HMI (Recommended - No Dependencies)")
            
            # Option 2: Enhanced HMI (if pymodbus available)
            if (self.available_components.get('enhanced_hmi.py', False) and 
                self.available_components['dependencies'].get('pymodbus', False)):
                options.append(('Enhanced HMI (PyModbus - Advanced Features)', 'enhanced'))
                print(f"{len(options)}. Enhanced HMI (PyModbus - Advanced Features)")
            
            # Option 3: Web Interface
            if (self.available_components.get('app.py', False) and 
                self.available_components['dependencies'].get('flask', False)):
                options.append(('Web HMI (Browser Interface)', 'web'))
                print(f"{len(options)}. Web HMI (Browser Interface)")
            
            # Option 4: Desktop HMI
            if (self.available_components.get('harmony_hmi_desktop.py', False) and 
                self.available_components['dependencies'].get('tkinter', False)):
                options.append(('Desktop HMI (Native Application)', 'desktop'))
                print(f"{len(options)}. Desktop HMI (Native Application)")
            
            # Option 5: Complete System (if multiple components available)
            if len([o for o in options if o[1] in ['web', 'desktop']]) >= 2:
                options.append(('Complete System (Web + Desktop + Bridge)', 'complete'))
                print(f"{len(options)}. Complete System (Web + Desktop + Bridge)")
            
            # Always available options
            options.append(('System Information', 'info'))
            print(f"{len(options)}. System Information")
            
            options.append(('Check Arduino PLC Connection', 'test_plc'))
            print(f"{len(options)}. Check Arduino PLC Connection")
            
            options.append(('Install Dependencies', 'install'))
            print(f"{len(options)}. Install Dependencies")
            
            options.append(('Exit', 'exit'))
            print(f"{len(options)}. Exit")
            
            print("=" * 60)
            
            try:
                choice = input("Enter your choice: ").strip()
                choice_num = int(choice) - 1
                
                if 0 <= choice_num < len(options):
                    action = options[choice_num][1]
                    
                    if action == 'standalone':
                        return self.launch_standalone()
                    elif action == 'enhanced':
                        return self.launch_enhanced()
                    elif action == 'web':
                        return self.launch_web()
                    elif action == 'desktop':
                        return self.launch_desktop()
                    elif action == 'complete':
                        return self.launch_complete_system()
                    elif action == 'info':
                        self.show_system_info()
                    elif action == 'test_plc':
                        self.test_plc_connection()
                    elif action == 'install':
                        self.install_dependencies()
                    elif action == 'exit':
                        print("Goodbye!")
                        return
                else:
                    print("Invalid choice. Please try again.")
                    
            except (ValueError, KeyboardInterrupt):
                print("\nExiting...")
                return
    
    def launch_standalone(self):
        """Launch standalone HMI."""
        print("\n" + "=" * 60)
        print("LAUNCHING STANDALONE HMI")
        print("=" * 60)
        print("Perfect for air-gapped systems!")
        print("No external dependencies required.")
        print("=" * 60)
        
        if not self.available_components.get('standalone_hmi.py', False):
            print("Error: standalone_hmi.py not found")
            return False
        
        return self.start_component('standalone_hmi', 'standalone_hmi.py')
    
    def launch_enhanced(self):
        """Launch enhanced HMI with fixed PyModbus compatibility."""
        print("\n" + "=" * 60)
        print("LAUNCHING ENHANCED HMI (PyModbus)")
        print("=" * 60)
        print("Advanced features with professional diagnostics")
        print("Fixed PyModbus compatibility issues")
        print("=" * 60)
        
        # Check if we have the fixed version
        if Path('enhanced_hmi_fixed.py').exists():
            return self.start_component('enhanced_hmi', 'enhanced_hmi_fixed.py')
        elif self.available_components.get('enhanced_hmi.py', False):
            print("⚠ Using original enhanced_hmi.py - may have compatibility issues")
            print("Consider using the fixed version or standalone HMI")
            return self.start_component('enhanced_hmi', 'enhanced_hmi.py')
        else:
            print("Error: Enhanced HMI files not found")
            return False
    
    def launch_web(self):
        """Launch web HMI."""
        print("\n" + "=" * 60)
        print("LAUNCHING WEB HMI")
        print("=" * 60)
        print("Access via: http://localhost:5000")
        print("Modern browser interface with diagnostics")
        print("=" * 60)
        
        if not self.available_components.get('app.py', False):
            print("Error: app.py not found")
            return False
        
        return self.start_component('web_hmi', 'app.py')
    
    def launch_desktop(self):
        """Launch desktop HMI."""
        print("\n" + "=" * 60)
        print("LAUNCHING DESKTOP HMI")
        print("=" * 60)
        print("Native desktop application")
        print("Real-time monitoring and control")
        print("=" * 60)
        
        if not self.available_components.get('harmony_hmi_desktop.py', False):
            print("Error: harmony_hmi_desktop.py not found")
            return False
        
        return self.start_component('desktop_hmi', 'harmony_hmi_desktop.py')
    
    def launch_complete_system(self):
        """Launch complete system with multiple components."""
        print("\n" + "=" * 60)
        print("LAUNCHING COMPLETE SYSTEM")
        print("=" * 60)
        print("Starting multiple components...")
        print("=" * 60)
        
        components_started = 0
        
        # Start web HMI
        if (self.available_components.get('app.py', False) and 
            self.available_components['dependencies'].get('flask', False)):
            if self.start_component('web_hmi', 'app.py'):
                components_started += 1
                time.sleep(2)  # Allow web server to start
        
        # Start desktop HMI
        if (self.available_components.get('harmony_hmi_desktop.py', False) and 
            self.available_components['dependencies'].get('tkinter', False)):
            if self.start_component('desktop_hmi', 'harmony_hmi_desktop.py'):
                components_started += 1
                time.sleep(2)
        
        # Start integration bridge if available
        if self.available_components.get('integration_bridge.py', False):
            if self.start_component('bridge', 'integration_bridge.py'):
                components_started += 1
        
        if components_started > 0:
            print(f"\n✓ Started {components_started} components successfully")
            self.display_system_status()
            return True
        else:
            print("✗ Failed to start system components")
            return False
    
    def start_component(self, name, script):
        """Start a system component."""
        try:
            print(f"Starting {name}...")
            process = subprocess.Popen(
                [sys.executable, script],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )
            
            self.processes[name] = process
            logger.info(f"{name} started with PID {process.pid}")
            
            # Monitor process in background thread
            monitor_thread = threading.Thread(
                target=self.monitor_process,
                args=(name, process),
                daemon=True
            )
            monitor_thread.start()
            
            # Give process time to start
            time.sleep(1)
            
            # Check if process is still running
            if process.poll() is None:
                print(f"✓ {name} started successfully (PID: {process.pid})")
                return True
            else:
                print(f"✗ {name} failed to start")
                return False
            
        except Exception as e:
            print(f"✗ Failed to start {name}: {e}")
            return False
    
    def monitor_process(self, name, process):
        """Monitor a subprocess."""
        try:
            while self.running and process.poll() is None:
                time.sleep(0.5)
            
            # Process has terminated
            if process.returncode is not None and process.returncode != 0:
                logger.error(f"{name} process terminated with code {process.returncode}")
                
                # Read stderr for errors
                if process.stderr:
                    stderr_output = process.stderr.read()
                    if stderr_output:
                        logger.error(f"[{name.upper()} ERROR] {stderr_output}")
            
        except Exception as e:
            logger.error(f"Error monitoring {name} process: {e}")
    
    def display_system_status(self):
        """Display current system status."""
        print("\n" + "=" * 60)
        print("SYSTEM STATUS")
        print("=" * 60)
        
        for name, process in self.processes.items():
            status = "RUNNING" if process.poll() is None else "STOPPED"
            pid = process.pid if process.poll() is None else "N/A"
            print(f"{name.upper():15} | {status:8} | PID: {pid}")
        
        print("=" * 60)
        print("Access Points:")
        if 'web_hmi' in self.processes and self.processes['web_hmi'].poll() is None:
            print("  Web Interface:    http://localhost:5000")
        if 'desktop_hmi' in self.processes and self.processes['desktop_hmi'].poll() is None:
            print("  Desktop HMI:      GUI window should be open")
        print("  Arduino PLC:      192.168.1.100:502 (if connected)")
        print("=" * 60)
        print("Press Ctrl+C to stop all components")
        
        # Keep running until interrupted
        try:
            while self.running:
                time.sleep(1)
        except KeyboardInterrupt:
            pass
    
    def test_plc_connection(self):
        """Test Arduino PLC connection."""
        print("\n" + "=" * 60)
        print("TESTING ARDUINO PLC CONNECTION")
        print("=" * 60)
        print("Target: 192.168.1.100:502")
        
        import socket
        
        try:
            # Test basic network connectivity
            print("Testing network connection...")
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex(('192.168.1.100', 502))
            sock.close()
            
            if result == 0:
                print("✓ Network connection successful")
                print("  Arduino PLC is responding on port 502")
                print("  Modbus TCP communication should work")
            else:
                print("✗ Network connection failed")
                print("  Check Arduino PLC network configuration:")
                print("    - Verify IP address (default: 192.168.1.100)")
                print("    - Check Ethernet cable connection")
                print("    - Ensure both devices on same network")
                print("    - Try ping 192.168.1.100")
                
        except Exception as e:
            print(f"✗ Connection test error: {e}")
        
        print("=" * 60)
        input("Press Enter to continue...")
    
    def install_dependencies(self):
        """Guide user through dependency installation."""
        print("\n" + "=" * 60)
        print("DEPENDENCY INSTALLATION")
        print("=" * 60)
        
        missing_deps = [dep for dep, available in self.available_components['dependencies'].items() if not available]
        
        if not missing_deps:
            print("✓ All optional dependencies are already installed!")
            print("\nAvailable components:")
            for dep in self.available_components['dependencies']:
                print(f"  • {dep}")
        else:
            print("Missing optional dependencies:")
            for dep in missing_deps:
                print(f"  • {dep}")
            
            print(f"\nTo install missing dependencies:")
            print(f"  pip install {' '.join(missing_deps)}")
            
            install_now = input("\nWould you like to install them now? (y/N): ").strip().lower()
            
            if install_now in ['y', 'yes']:
                try:
                    print(f"\nInstalling dependencies...")
                    result = subprocess.run([
                        sys.executable, '-m', 'pip', 'install'
                    ] + missing_deps, capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        print("✓ Dependencies installed successfully!")
                        print("Rechecking system capabilities...")
                        self.check_dependencies()
                    else:
                        print("✗ Installation failed:")
                        print(result.stderr)
                        
                except Exception as e:
                    print(f"✗ Installation error: {e}")
            else:
                print("\nYou can install them later using:")
                print(f"  pip install {' '.join(missing_deps)}")
        
        print("=" * 60)
        input("Press Enter to continue...")
    
    def show_system_info(self):
        """Display detailed system information."""
        print("\n" + "=" * 60)
        print("SYSTEM INFORMATION")
        print("=" * 60)
        
        print(f"Python Version: {sys.version}")
        print(f"Platform: {sys.platform}")
        print(f"Working Directory: {os.getcwd()}")
        
        print("\nComponent Architecture:")
        print("  ┌─────────────┐    ┌─────────────┐    ┌─────────────┐")
        print("  │   Web HMI   │    │ Desktop HMI │    │ Arduino PLC │")
        print("  │   (Flask)   │    │  (Tkinter)  │    │ (P1AM-200)  │")
        print("  │  Port 5000  │    │    GUI      │    │192.168.1.100│")
        print("  └──────┬──────┘    └──────┬──────┘    └──────┬──────┘")
        print("         │                  │                  │")
        print("         └──────────────────┼──────────────────┘")
        print("                            │")
        print("                   ┌────────▼────────┐")
        print("                   │ Integration     │")
        print("                   │ Bridge          │")
        print("                   │ (Optional)      │")
        print("                   └─────────────────┘")
        
        print("\nCommunication Protocols:")
        print("  • Modbus TCP:     PLC ↔ HMI (port 502)")
        print("  • HTTP REST API:  Web interface (port 5000)")
        print("  • Inter-process:  Component coordination")
        
        print("\nFile Status:")
        for file, available in self.available_components.items():
            if file != 'dependencies':
                status = "✓ Available" if available else "✗ Missing"
                print(f"  {file:<25}: {status}")
        
        print("\nDependency Status:")
        for dep, available in self.available_components['dependencies'].items():
            status = "✓ Installed" if available else "✗ Not installed"
            print(f"  {dep:<15}: {status}")
        
        print("=" * 60)
        input("Press Enter to continue...")
    
    def shutdown_all(self):
        """Shutdown all running processes."""
        logger.info("Shutting down all components...")
        self.running = False
        
        for name, process in self.processes.items():
            try:
                if process.poll() is None:  # Process is still running
                    logger.info(f"Terminating {name}...")
                    process.terminate()
                    
                    # Wait for graceful shutdown
                    try:
                        process.wait(timeout=5)
                        logger.info(f"{name} terminated gracefully")
                    except subprocess.TimeoutExpired:
                        logger.warning(f"Force killing {name}...")
                        process.kill()
                        process.wait()
                        logger.info(f"{name} force killed")
                
            except Exception as e:
                logger.error(f"Error stopping {name}: {e}")
        
        logger.info("All components stopped")

def main():
    """Main launcher entry point."""
    launcher = UnifiedLauncher()
    
    try:
        launcher.show_main_menu()
    except KeyboardInterrupt:
        print("\nShutting down...")
        launcher.shutdown_all()

if __name__ == "__main__":
    main()
