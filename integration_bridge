#!/usr/bin/env python3
"""
INTEGRATION BRIDGE - Tank Level Control System
Coordinates communication between all three components:
1. Web HMI (Flask application) 
2. Desktop HMI (Tkinter application)
3. Arduino PLC Controller

This bridge ensures data synchronization and provides a unified control interface.
"""

import threading
import time
import logging
import json
import queue
import signal
import sys
from datetime import datetime
from typing import Dict, Any, Optional

import requests
from pymodbus.client import ModbusTcpClient
from pymodbus.exceptions import ModbusIOException, ConnectionException

from config import Config

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - [BRIDGE] - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('integration_bridge.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class IntegrationBridge:
    """
    Central coordination hub for Tank Level Control System
    Manages communication between web HMI, desktop HMI, and PLC
    """
    
    def __init__(self):
        self.running = True
        self.threads = []
        
        # Component status tracking
        self.web_status = {"connected": False, "last_check": 0}
        self.desktop_status = {"connected": False, "last_check": 0}
        self.plc_status = {"connected": False, "last_check": 0}
        
        # Data synchronization
        self.shared_data = {
            "timestamp": time.time(),
            "tank_levels": [0.0] * Config.NUM_TANKS,
            "flow_rates": [0.0] * Config.NUM_FLOWS,
            "pump_states": [False, False],
            "valve_states": [False] * Config.NUM_TANKS,
            "pump_runtimes": [0.0, 0.0],
            "system_mode": 0,
            "connection_quality": 0,
            "main_epo": False,
            "hh_alarms": [False] * Config.NUM_TANKS
        }
        
        # Communication queues
        self.web_queue = queue.Queue(maxsize=10)
        self.desktop_queue = queue.Queue(maxsize=10)
        self.plc_queue = queue.Queue(maxsize=10)
        
        # Modbus client for direct PLC communication
        self.plc_client = None
        self.plc_connected = False
        
        # Setup signal handlers for graceful shutdown
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)
        
        logger.info("Integration Bridge initialized")
    
    def signal_handler(self, signum, frame):
        """Handle shutdown signals gracefully."""
        logger.info(f"Received signal {signum}, shutting down...")
        self.shutdown()
        sys.exit(0)
    
    def start(self):
        """Start all bridge services."""
        logger.info("=" * 60)
        logger.info("STARTING TANK CONTROL INTEGRATION BRIDGE")
        logger.info("=" * 60)
        
        # Initialize PLC connection
        self.initialize_plc_client()
        
        # Start monitoring threads
        self.start_threads()
        
        # Main coordination loop
        self.coordination_loop()
    
    def initialize_plc_client(self):
        """Initialize direct PLC communication."""
        try:
            self.plc_client = ModbusTcpClient(
                host=Config.PLC_IP,
                port=Config.PLC_PORT,
                timeout=Config.MODBUS_TIMEOUT
            )
            logger.info(f"PLC client initialized for {Config.PLC_IP}:{Config.PLC_PORT}")
        except Exception as e:
            logger.error(f"Failed to initialize PLC client: {e}")
    
    def start_threads(self):
        """Start all monitoring and communication threads."""
        
        # Web HMI monitoring thread
        web_thread = threading.Thread(
            target=self.monitor_web_hmi,
            name="WebHMI-Monitor",
            daemon=True
        )
        web_thread.start()
        self.threads.append(web_thread)
        
        # Desktop HMI monitoring thread  
        desktop_thread = threading.Thread(
            target=self.monitor_desktop_hmi,
            name="DesktopHMI-Monitor", 
            daemon=True
        )
        desktop_thread.start()
        self.threads.append(desktop_thread)
        
        # PLC communication thread
        plc_thread = threading.Thread(
            target=self.monitor_plc_communication,
            name="PLC-Monitor",
            daemon=True
        )
        plc_thread.start()
        self.threads.append(plc_thread)
        
        # Data synchronization thread
        sync_thread = threading.Thread(
            target=self.data_synchronization_loop,
            name="Data-Sync",
            daemon=True
        )
        sync_thread.start()
        self.threads.append(sync_thread)
        
        logger.info(f"Started {len(self.threads)} monitoring threads")
    
    def monitor_web_hmi(self):
        """Monitor web HMI application status."""
        web_api_url = "http://localhost:5000/api"
        
        while self.running:
            try:
                # Check web HMI status
                response = requests.get(f"{web_api_url}/status", timeout=3)
                
                if response.status_code == 200:
                    data = response.json()
                    
                    # Update shared data with web HMI data
                    if not self.web_status["connected"]:
                        logger.info("Web HMI connection established")
                    
                    self.web_status["connected"] = True
                    self.web_status["last_check"] = time.time()
                    
                    # Synchronize data from web interface
                    self.update_shared_data_from_web(data)
                    
                else:
                    if self.web_status["connected"]:
                        logger.warning("Web HMI connection lost")
                    self.web_status["connected"] = False
                    
            except Exception as e:
                if self.web_status["connected"]:
                    logger.warning(f"Web HMI monitoring error: {e}")
                self.web_status["connected"] = False
            
            time.sleep(2)  # Check every 2 seconds
    
    def monitor_desktop_hmi(self):
        """Monitor desktop HMI application."""
        # For now, this is a placeholder since the desktop app doesn't have an API
        # In a full implementation, this could use IPC, file monitoring, or other methods
        
        while self.running:
            try:
                # Check if desktop HMI process is running (simplified check)
                # This could be enhanced with actual process monitoring
                self.desktop_status["connected"] = True
                self.desktop_status["last_check"] = time.time()
                
            except Exception as e:
                logger.error(f"Desktop HMI monitoring error: {e}")
                self.desktop_status["connected"] = False
            
            time.sleep(5)  # Check every 5 seconds
    
    def monitor_plc_communication(self):
        """Monitor direct PLC communication."""
        
        while self.running:
            try:
                if not self.plc_connected:
                    self.connect_to_plc()
                
                if self.plc_connected:
                    # Read essential data from PLC
                    success = self.read_plc_data()
                    
                    if not success:
                        self.plc_connected = False
                        logger.warning("Lost PLC connection")
                    else:
                        self.plc_status["connected"] = True
                        self.plc_status["last_check"] = time.time()
                
            except Exception as e:
                logger.error(f"PLC monitoring error: {e}")
                self.plc_connected = False
                self.plc_status["connected"] = False
            
            time.sleep(Config.POLLING_INTERVAL)
    
    def connect_to_plc(self):
        """Establish connection to PLC."""
        try:
            if self.plc_client and self.plc_client.connect():
                self.plc_connected = True
                logger.info("Bridge established direct PLC connection")
                return True
        except Exception as e:
            logger.error(f"Bridge PLC connection failed: {e}")
        
        return False
    
    def read_plc_data(self):
        """Read data directly from PLC."""
        try:
            if not self.plc_client:
                return False
            
            # Read holding registers for tank levels
            result = self.plc_client.read_holding_registers(
                Config.REG_LEVEL_START, 
                Config.NUM_TANKS, 
                unit=Config.MODBUS_UNIT_ID
            )
            
            if not result.isError():
                # Update shared data with PLC readings
                for i, level in enumerate(result.registers[:Config.NUM_TANKS]):
                    self.shared_data["tank_levels"][i] = level / 100.0
                
                self.shared_data["timestamp"] = time.time()
                return True
            
        except Exception as e:
            logger.error(f"Error reading PLC data: {e}")
        
        return False
    
    def update_shared_data_from_web(self, web_data):
        """Update shared data with information from web HMI."""
        try:
            if "tank_levels" in web_data:
                self.shared_data["tank_levels"] = web_data["tank_levels"]
            
            if "flow_rates" in web_data:
                self.shared_data["flow_rates"] = web_data["flow_rates"]
            
            if "pump_states" in web_data:
                self.shared_data["pump_states"] = web_data["pump_states"]
            
            if "connection_quality" in web_data:
                self.shared_data["connection_quality"] = web_data["connection_quality"]
            
            self.shared_data["timestamp"] = time.time()
            
        except Exception as e:
            logger.error(f"Error updating shared data from web: {e}")
    
    def data_synchronization_loop(self):
        """Main data synchronization between all components."""
        
        while self.running:
            try:
                # Determine authoritative data source
                # Priority: Direct PLC > Web HMI > Desktop HMI
                
                if self.plc_status["connected"]:
                    # PLC is authoritative source
                    self.sync_from_plc()
                elif self.web_status["connected"]:
                    # Web HMI is authoritative source  
                    self.sync_from_web()
                
                # Broadcast current state to all components
                self.broadcast_data()
                
            except Exception as e:
                logger.error(f"Data synchronization error: {e}")
            
            time.sleep(1)  # Sync every second
    
    def sync_from_plc(self):
        """Synchronize data from direct PLC connection."""
        # Data is already updated in monitor_plc_communication
        pass
    
    def sync_from_web(self):
        """Synchronize data from web HMI."""
        # Data is already updated in monitor_web_hmi
        pass
    
    def broadcast_data(self):
        """Broadcast current data state to all components."""
        # This could be enhanced to push updates to components
        # For now, components pull data as needed
        pass
    
    def coordination_loop(self):
        """Main coordination and status reporting loop."""
        
        while self.running:
            try:
                # Log system status periodically
                self.log_system_status()
                
                # Perform health checks
                self.perform_health_checks()
                
                # Handle any queued commands
                self.process_command_queues()
                
            except KeyboardInterrupt:
                logger.info("Received keyboard interrupt, shutting down...")
                break
            except Exception as e:
                logger.error(f"Coordination loop error: {e}")
            
            time.sleep(10)  # Main loop every 10 seconds
        
        self.shutdown()
    
    def log_system_status(self):
        """Log comprehensive system status."""
        logger.info("=" * 50)
        logger.info("SYSTEM STATUS REPORT")
        logger.info("=" * 50)
        
        # Component status
        logger.info(f"Web HMI:     {'ONLINE' if self.web_status['connected'] else 'OFFLINE'}")
        logger.info(f"Desktop HMI: {'ONLINE' if self.desktop_status['connected'] else 'OFFLINE'}")
        logger.info(f"PLC:         {'ONLINE' if self.plc_status['connected'] else 'OFFLINE'}")
        
        # Data summary
        logger.info(f"Active Threads: {len([t for t in self.threads if t.is_alive()])}")
        logger.info(f"Data Age: {time.time() - self.shared_data['timestamp']:.1f}s")
        
        # Tank summary (first 3 tanks)
        levels = self.shared_data["tank_levels"][:3]
        logger.info(f"Tank Levels: {[f'{l:.1f}%' for l in levels]}")
        
        # Pump status
        pumps = self.shared_data["pump_states"]
        logger.info(f"Pumps: P1={'ON' if pumps[0] else 'OFF'}, P2={'ON' if pumps[1] else 'OFF'}")
        
        logger.info("=" * 50)
    
    def perform_health_checks(self):
        """Perform system health checks."""
        issues = []
        
        # Check thread health
        dead_threads = [t for t in self.threads if not t.is_alive()]
        if dead_threads:
            issues.append(f"{len(dead_threads)} threads have died")
        
        # Check data freshness
        data_age = time.time() - self.shared_data["timestamp"]
        if data_age > 30:  # Data older than 30 seconds
            issues.append(f"Data is {data_age:.1f}s old")
        
        # Check component connectivity
        if not any([self.web_status["connected"], self.plc_status["connected"]]):
            issues.append("No data sources available")
        
        # Report issues
        if issues:
            for issue in issues:
                logger.warning(f"Health Check: {issue}")
        else:
            logger.debug("Health Check: All systems normal")
    
    def process_command_queues(self):
        """Process any pending commands from component queues."""
        # Process web commands
        try:
            while not self.web_queue.empty():
                command = self.web_queue.get_nowait()
                self.execute_command(command, "web")
        except queue.Empty:
            pass
        
        # Process desktop commands
        try:
            while not self.desktop_queue.empty():
                command = self.desktop_queue.get_nowait()
                self.execute_command(command, "desktop")
        except queue.Empty:
            pass
        
        # Process PLC commands
        try:
            while not self.plc_queue.empty():
                command = self.plc_queue.get_nowait()
                self.execute_command(command, "plc")
        except queue.Empty:
            pass
    
    def execute_command(self, command: Dict[str, Any], source: str):
        """Execute a command from one of the components."""
        try:
            logger.info(f"Executing command from {source}: {command}")
            
            # Command execution logic would go here
            # This could include pump controls, valve operations, etc.
            
        except Exception as e:
            logger.error(f"Command execution error: {e}")
    
    def get_system_data(self) -> Dict[str, Any]:
        """Get current system data (for API access)."""
        return {
            "timestamp": self.shared_data["timestamp"],
            "components": {
                "web_hmi": self.web_status,
                "desktop_hmi": self.desktop_status, 
                "plc": self.plc_status
            },
            "data": self.shared_data
        }
    
    def shutdown(self):
        """Gracefully shutdown the bridge."""
        logger.info("Shutting down Integration Bridge...")
        
        self.running = False
        
        # Close PLC connection
        if self.plc_client:
            try:
                self.plc_client.close()
                logger.info("PLC connection closed")
            except Exception as e:
                logger.error(f"Error closing PLC connection: {e}")
        
        # Wait for threads to finish
        for thread in self.threads:
            if thread.is_alive():
                thread.join(timeout=2)
        
        logger.info("Integration Bridge shutdown complete")

def main():
    """Main entry point for the integration bridge."""
    
    print("=" * 60)
    print("TANK LEVEL CONTROL SYSTEM - INTEGRATION BRIDGE")
    print("=" * 60)
    print(f"PLC Target: {Config.PLC_IP}:{Config.PLC_PORT}")
    print("Web HMI Target: http://localhost:5000")
    print("Starting coordination services...")
    print("=" * 60)
    
    # Create and start the bridge
    bridge = IntegrationBridge()
    
    try:
        bridge.start()
    except KeyboardInterrupt:
        logger.info("Bridge stopped by user")
    except Exception as e:
        logger.error(f"Bridge error: {e}")
        bridge.shutdown()

if __name__ == "__main__":
    main()
