#!/usr/bin/env python3
"""
=====================================================
TANK LEVEL CONTROL SYSTEM - HMI APPLICATION v2.0
=====================================================

Enhanced Human Machine Interface for P1AM-200 Tank Control System

Features:
- Real-time monitoring of tank levels and flow rates
- Manual control of pumps and valves
- System diagnostics and connection monitoring
- Alarm logging and status display
- Connection quality monitoring
- Comprehensive error handling

Author: Enhanced by Claude AI
Version: 2.0
Last Modified: August 2025
"""

import tkinter as tk
from tkinter import ttk, messagebox
from pymodbus.client import ModbusTcpClient
from pymodbus.exceptions import ModbusIOException, ConnectionException
import threading
import time
import queue
import logging
import socket
from datetime import datetime

# =====================================================
# LOGGING CONFIGURATION
# =====================================================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('hmi_system.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# =====================================================
# SYSTEM CONFIGURATION
# =====================================================
PLC_IP = "192.168.1.100"
PLC_PORT = 502
MODBUS_UNIT_ID = 1
POLLING_INTERVAL = 0.5
MODBUS_TIMEOUT = 3
MAX_RECONNECT_ATTEMPTS = 5
RECONNECT_DELAY = 2

# System parameters
NUM_TANKS = 9
NUM_FLOWS = 2

# Modbus register addresses (must match Arduino code)
REG_LEVEL_START = 0         # Tank levels (0-8)
REG_FLOW_START = 10         # Flow readings (10-11)
REG_MODE_STATUS = 20        # Input register for mode
REG_PUMP_RUNTIME1 = 22      # Pump 1 runtime (seconds)
REG_PUMP_RUNTIME2 = 23      # Pump 2 runtime (seconds)
REG_WATCHDOG = 24           # System watchdog counter
REG_SYSTEM_STATUS = 25      # System status flags

COIL_FILL_START = 0         # Fill valve coils (0-8)
COIL_PUMP_LEAD = 10         # Lead pump coil
COIL_PUMP_LAG = 11          # Lag pump coil

DISCRETE_HH_BASE = 0        # High-high switches (0-8)
DISCRETE_EPO_BASE = 10      # Tank EPO switches (10-18)
DISCRETE_MAIN_EPO = 20      # Main EPO switch

class EnhancedHMIApp(tk.Tk):
    """
    Enhanced HMI Application with comprehensive error handling,
    diagnostics, and monitoring capabilities.
    """
    
    def __init__(self):
        super().__init__()
        
        # Window configuration
        self.title("P1AM-200 HMI v2.0 - Enhanced Tank Control System")
        self.geometry("1400x1000")
        self.configure(bg="#f0f0f0")
        self.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        # Modbus client
        self.client = None
        self.connected = False
        self.reconnect_attempts = 0
        
        # System monitoring
        self.last_successful_read = time.time()
        self.connection_quality = 0
        self.watchdog_counter = 0
        self.last_watchdog = 0
        self.stale_data_count = 0
        self.last_tank_values = [0.0] * NUM_TANKS
        
        # Data queues for thread communication
        self.data_queue = queue.Queue()
        self.command_queue = queue.Queue()
        
        # System state
        self.mode = 0
        self.pump_states = {COIL_PUMP_LEAD: False, COIL_PUMP_LAG: False}
        self.valve_states = [False] * NUM_TANKS
        self.tank_levels = [0.0] * NUM_TANKS
        self.flow_rates = [0.0] * NUM_FLOWS
        self.pump_runtimes = [0.0, 0.0]
        self.hh_alarms = [False] * NUM_TANKS
        self.epo_states = [False] * NUM_TANKS
        self.main_epo = False
        self.system_status = 0
        
        # Threading control
        self.polling = True
        self.poll_thread = None
        
        # Create GUI
        self.create_widgets()
        
        # Initialize system
        self.initialize_client()
        self.start_polling()
        
        logger.info("HMI Application started")
    
    def initialize_client(self):
        """Initialize Modbus TCP client with enhanced error handling."""
        try:
            if self.client:
                self.client.close()
            
            self.client = ModbusTcpClient(
                host=PLC_IP,
                port=PLC_PORT,
                timeout=MODBUS_TIMEOUT,
                retry_on_empty=True,
                retries=3
            )
            
            logger.info(f"Modbus client initialized for {PLC_IP}:{PLC_PORT}")
            self.connected = False
            self.reconnect_attempts = 0
            
        except Exception as e:
            logger.error(f"Failed to initialize Modbus client: {e}")
            self.log_message(f"Client initialization error: {e}", alarm=True)
    
    def validate_network_connection(self):
        """
        Validate network connectivity to PLC before attempting Modbus connection.
        Returns True if network connection is possible.
        """
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            result = sock.connect_ex((PLC_IP, PLC_PORT))
            sock.close()
            
            if result == 0:
                return True
            else:
                logger.warning(f"Cannot reach PLC at network level (error {result})")
                return False
                
        except Exception as e:
            logger.error(f"Network validation error: {e}")
            return False
    
    def connect_with_retry(self):
        """
        Connect to PLC with retry logic and comprehensive error reporting.
        Returns True if connection successful.
        """
        if not self.validate_network_connection():
            return False
        
        for attempt in range(MAX_RECONNECT_ATTEMPTS):
            try:
                if self.client.connect():
                    self.connected = True
                    self.reconnect_attempts = 0
                    self.connection_quality = min(100, self.connection_quality + 20)
                    logger.info(f"Connected to PLC on attempt {attempt + 1}")
                    self.log_message(f"Connected to PLC (attempt {attempt + 1})")
                    return True
                else:
                    logger.warning(f"Connection attempt {attempt + 1} failed")
                    
            except Exception as e:
                logger.error(f"Connection error on attempt {attempt + 1}: {e}")
                
            if attempt < MAX_RECONNECT_ATTEMPTS - 1:
                time.sleep(RECONNECT_DELAY)
        
        self.connected = False
        self.reconnect_attempts += 1
        self.connection_quality = max(0, self.connection_quality - 30)
        return False
    
    def create_widgets(self):
        """Create and layout all GUI widgets with enhanced styling."""
        
        # =====================================================
        # HEADER FRAME - Connection and System Status
        # =====================================================
        header_frame = tk.Frame(self, bg="#2c3e50", height=80)
        header_frame.pack(fill='x', padx=5, pady=5)
        header_frame.pack_propagate(False)
        
        # Connection status
        self.conn_label = tk.Label(
            header_frame, 
            text="Initializing...", 
            fg="orange", 
            bg="#2c3e50",
            font=("Arial", 16, "bold")
        )
        self.conn_label.pack(side='left', padx=20, pady=10)
        
        # Connection quality indicator
        self.quality_label = tk.Label(
            header_frame, 
            text="Quality: ---%", 
            fg="white", 
            bg="#2c3e50",
            font=("Arial", 12)
        )
        self.quality_label.pack(side='left', padx=20, pady=10)
        
        # System mode display
        self.mode_label = tk.Label(
            header_frame, 
            text="Mode: Unknown", 
            fg="white", 
            bg="#2c3e50",
            font=("Arial", 16, "bold")
        )
        self.mode_label.pack(side='right', padx=20, pady=10)
        
        # Watchdog indicator
        self.watchdog_label = tk.Label(
            header_frame, 
            text="PLC: ---", 
            fg="white", 
            bg="#2c3e50",
            font=("Arial", 12)
        )
        self.watchdog_label.pack(side='right', padx=20, pady=10)
        
        # Emergency status
        self.epo_label = tk.Label(
            header_frame, 
            text="EPO: OK", 
            fg="white", 
            bg="#2c3e50",
            font=("Arial", 12, "bold")
        )
        self.epo_label.pack(side='right', padx=20, pady=10)
        
        # =====================================================
        # MAIN CONTENT AREA
        # =====================================================
        main_frame = tk.Frame(self, bg="#f0f0f0")
        main_frame.pack(fill='both', expand=True, padx=5, pady=5)
        
        # Left column - Tank levels and flows
        left_frame = tk.Frame(main_frame)
        left_frame.pack(side='left', fill='both', expand=True, padx=(0, 5))
        
        # Right column - Controls and status
        right_frame = tk.Frame(main_frame)
        right_frame.pack(side='right', fill='both', expand=True, padx=(5, 0))
        
        # =====================================================
        # TANK LEVELS DISPLAY
        # =====================================================
        tank_frame = tk.LabelFrame(
            left_frame, 
            text="Tank Levels (%)", 
            font=("Arial", 12, "bold"),
            bg="#f0f0f0"
        )
        tank_frame.pack(fill='x', pady=5)
        
        self.tank_level_vars = []
        self.tank_level_bars = []
        self.tank_status_labels = []
        
        # Create tank level displays with progress bars
        for i in range(NUM_TANKS):
            row_frame = tk.Frame(tank_frame)
            row_frame.pack(fill='x', padx=5, pady=2)
            
            # Tank label
            tk.Label(
                row_frame, 
                text=f"Tank {i+1}:", 
                width=8,
                font=("Arial", 10)
            ).pack(side='left')
            
            # Progress bar
            progress = ttk.Progressbar(
                row_frame, 
                length=200, 
                mode='determinate',
                maximum=100
            )
            progress.pack(side='left', padx=5)
            self.tank_level_bars.append(progress)
            
            # Value label
            var = tk.StringVar(value="---.-%")
            lbl = tk.Label(
                row_frame, 
                textvariable=var,
                width=8,
                font=("Arial", 10, "bold")
            )
            lbl.pack(side='left', padx=5)
            self.tank_level_vars.append(var)
            
            # Status indicator (HH alarm, filling, etc.)
            status_lbl = tk.Label(
                row_frame, 
                text="OK",
                width=10,
                font=("Arial", 9),
                fg="green"
            )
            status_lbl.pack(side='left', padx=5)
            self.tank_status_labels.append(status_lbl)
        
        # =====================================================
        # FLOW READINGS DISPLAY
        # =====================================================
        flow_frame = tk.LabelFrame(
            left_frame, 
            text="Flow Readings (GPM)", 
            font=("Arial", 12, "bold"),
            bg="#f0f0f0"
        )
        flow_frame.pack(fill='x', pady=5)
        
        self.flow_vars = []
        for i in range(NUM_FLOWS):
            row_frame = tk.Frame(flow_frame)
            row_frame.pack(fill='x', padx=5, pady=3)
            
            tk.Label(
                row_frame, 
                text=f"Flow {i+1}:", 
                width=8,
                font=("Arial", 10)
            ).pack(side='left')
            
            var = tk.StringVar(value="---.-- GPM")
            lbl = tk.Label(
                row_frame, 
                textvariable=var,
                font=("Arial", 10, "bold")
            )
            lbl.pack(side='left', padx=5)
            self.flow_vars.append(var)
        
        # =====================================================
        # PUMP RUNTIME DISPLAY
        # =====================================================
        runtime_frame = tk.LabelFrame(
            left_frame, 
            text="Pump Runtime (Hours)", 
            font=("Arial", 12, "bold"),
            bg="#f0f0f0"
        )
        runtime_frame.pack(fill='x', pady=5)
        
        self.runtime_vars = []
        for i in range(2):
            row_frame = tk.Frame(runtime_frame)
            row_frame.pack(fill='x', padx=5, pady=3)
            
            tk.Label(
                row_frame, 
                text=f"Pump {i+1}:", 
                width=8,
                font=("Arial", 10)
            ).pack(side='left')
            
            var = tk.StringVar(value="---.-- hrs")
            lbl = tk.Label(
                row_frame, 
                textvariable=var,
                font=("Arial", 10, "bold")
            )
            lbl.pack(side='left', padx=5)
            self.runtime_vars.append(var)
        
        # =====================================================
        # PUMP CONTROL
        # =====================================================
        pump_frame = tk.LabelFrame(
            right_frame, 
            text="Pump Control", 
            font=("Arial", 12, "bold"),
            bg="#f0f0f0"
        )
        pump_frame.pack(fill='x', pady=5)
        
        pump_inner = tk.Frame(pump_frame)
        pump_inner.pack(pady=10)
        
        self.pump1_btn = tk.Button(
            pump_inner, 
            text="Pump 1 OFF", 
            width=15,
            height=2,
            font=("Arial", 10, "bold"),
            command=lambda: self.toggle_pump(COIL_PUMP_LEAD)
        )
        self.pump1_btn.grid(row=0, column=0, padx=10, pady=5)
        
        self.pump2_btn = tk.Button(
            pump_inner, 
            text="Pump 2 OFF", 
            width=15,
            height=2,
            font=("Arial", 10, "bold"),
            command=lambda: self.toggle_pump(COIL_PUMP_LAG)
        )
        self.pump2_btn.grid(row=0, column=1, padx=10, pady=5)
        
        # =====================================================
        # VALVE CONTROL
        # =====================================================
        valve_frame = tk.LabelFrame(
            right_frame, 
            text="Tank Fill Valve Control", 
            font=("Arial", 12, "bold"),
            bg="#f0f0f0"
        )
        valve_frame.pack(fill='x', pady=5)
        
        valve_inner = tk.Frame(valve_frame)
        valve_inner.pack(pady=5)
        
        self.valve_btns = []
        for i in range(NUM_TANKS):
            btn = tk.Button(
                valve_inner, 
                text=f"V{i+1}\nCLOSED", 
                width=8,
                height=2,
                font=("Arial", 9, "bold"),
                command=lambda idx=i: self.toggle_valve(idx)
            )
            btn.grid(row=i//5, column=i%5, padx=2, pady=2)
            self.valve_btns.append(btn)
        
        # =====================================================
        # CONTROL BUTTONS
        # =====================================================
        control_frame = tk.LabelFrame(
            right_frame, 
            text="System Control", 
            font=("Arial", 12, "bold"),
            bg="#f0f0f0"
        )
        control_frame.pack(fill='x', pady=5)
        
        btn_frame = tk.Frame(control_frame)
        btn_frame.pack(pady=10)
        
        tk.Button(
            btn_frame, 
            text="Diagnostics", 
            width=12,
            height=1,
            font=("Arial", 10),
            command=self.open_diagnostics
        ).pack(side='left', padx=5)
        
        tk.Button(
            btn_frame, 
            text="Reconnect", 
            width=12,
            height=1,
            font=("Arial", 10),
            command=self.force_reconnect
        ).pack(side='left', padx=5)
        
        tk.Button(
            btn_frame, 
            text="Emergency Stop", 
            width=12,
            height=1,
            font=("Arial", 10),
            bg="#e74c3c",
            fg="white",
            command=self.emergency_stop
        ).pack(side='left', padx=5)
        
        tk.Button(
            btn_frame, 
            text="Clear Alarms", 
            width=12,
            height=1,
            font=("Arial", 10),
            bg="#f39c12",
            fg="white",
            command=self.clear_alarms
        ).pack(side='left', padx=5)
        
        # =====================================================
        # ALARMS AND STATUS LOG
        # =====================================================
        status_frame = tk.LabelFrame(
            right_frame, 
            text="System Log & Alarms", 
            font=("Arial", 12, "bold"),
            bg="#f0f0f0"
        )
        status_frame.pack(fill='both', expand=True, pady=5)
        
        # Create text widget with scrollbar
        text_frame = tk.Frame(status_frame)
        text_frame.pack(fill='both', expand=True, padx=5, pady=5)
        
        self.status_text = tk.Text(
            text_frame, 
            height=15, 
            font=("Courier", 9),
            wrap='word'
        )
        
        scrollbar = tk.Scrollbar(text_frame, orient='vertical', command=self.status_text.yview)
        self.status_text.configure(yscrollcommand=scrollbar.set)
        
        self.status_text.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')
        
        # Configure text tags for different message types
        self.status_text.tag_configure("alarm", foreground="red", font=("Courier", 9, "bold"))
        self.status_text.tag_configure("warning", foreground="orange", font=("Courier", 9, "bold"))
        self.status_text.tag_configure("normal", foreground="black", font=("Courier", 9))
        self.status_text.tag_configure("success", foreground="green", font=("Courier", 9))
    
    def log_message(self, message, alarm=False, warning=False):
        """
        Add timestamped message to status log with appropriate styling.
        
        Args:
            message (str): Message to log
            alarm (bool): True for alarm-level messages (red)
            warning (bool): True for warning-level messages (orange)
        """
        timestamp = datetime.now().strftime("%H:%M:%S")
        full_message = f"[{timestamp}] {message}\n"
        
        # Determine message type and color
        if alarm:
            tag = "alarm"
            level = "ALARM"
        elif warning:
            tag = "warning"
            level = "WARN"
        else:
            tag = "normal"
            level = "INFO"
        
        # Add to GUI
        self.status_text.insert(tk.END, full_message, tag)
        self.status_text.see(tk.END)
        
        # Keep log size manageable
        if int(self.status_text.index('end-1c').split('.')[0]) > 100:
            self.status_text.delete('1.0', '10.0')  # Remove first 10 lines
        
        # Log to file as well
        if alarm:
            logger.error(f"ALARM: {message}")
        elif warning:
            logger.warning(f"WARNING: {message}")
        else:
            logger.info(message)
    
    # =====================================================
    # MODBUS COMMUNICATION METHODS
    # =====================================================
    
    def read_input_registers(self, address, count):
        """Read input registers with error handling."""
        try:
            if not self.connected:
                return None
            result = self.client.read_input_registers(
                address=address, 
                count=count, 
                slave=MODBUS_UNIT_ID
            )
            if result.isError():
                logger.warning(f"Input register read error at {address}: {result}")
            return result
        except Exception as e:
            logger.error(f"Input register read exception at {address}: {e}")
            return None
    
    def read_holding_registers(self, address, count):
        """Read holding registers with error handling."""
        try:
            if not self.connected:
                return None
            result = self.client.read_holding_registers(
                address=address, 
                count=count, 
                slave=MODBUS_UNIT_ID
            )
            if result.isError():
                logger.warning(f"Holding register read error at {address}: {result}")
            return result
        except Exception as e:
            logger.error(f"Holding register read exception at {address}: {e}")
            return None
    
    def read_coils(self, address, count):
        """Read coils with error handling."""
        try:
            if not self.connected:
                return None
            result = self.client.read_coils(
                address=address, 
                count=count, 
                slave=MODBUS_UNIT_ID
            )
            if result.isError():
                logger.warning(f"Coil read error at {address}: {result}")
            return result
        except Exception as e:
            logger.error(f"Coil read exception at {address}: {e}")
            return None
    
    def read_discrete_inputs(self, address, count):
        """Read discrete inputs with error handling."""
        try:
            if not self.connected:
                return None
            result = self.client.read_discrete_inputs(
                address=address, 
                count=count, 
                slave=MODBUS_UNIT_ID
            )
            if result.isError():
                logger.warning(f"Discrete input read error at {address}: {result}")
            return result
        except Exception as e:
            logger.error(f"Discrete input read exception at {address}: {e}")
            return None
    
    def write_coil(self, address, value):
        """Write single coil with error handling."""
        try:
            if not self.connected:
                return False
            result = self.client.write_coil(
                address=address, 
                value=value, 
                slave=MODBUS_UNIT_ID
            )
            if result.isError():
                logger.warning(f"Coil write error at {address}: {result}")
                return False
            return True
        except Exception as e:
            logger.error(f"Coil write exception at {address}: {e}")
            return False
    
    # =====================================================
    # CONTROL METHODS
    # =====================================================
    
    def toggle_pump(self, coil_addr):
        """
        Toggle pump state by reading current state and writing opposite.
        
        Args:
            coil_addr (int): Modbus coil address for the pump
        """
        try:
            # Read current state
            result = self.read_coils(coil_addr, 1)
            if result and not result.isError():
                current_state = result.bits[0]
                new_state = not current_state
                
                # Write new state
                if self.write_coil(coil_addr, new_state):
                    pump_name = "Pump 1" if coil_addr == COIL_PUMP_LEAD else "Pump 2"
                    state_text = "ON" if new_state else "OFF"
                    self.log_message(f"Manual: {pump_name} turned {state_text}")
                else:
                    self.log_message(f"Failed to control pump at address {coil_addr}", alarm=True)
            else:
                self.log_message(f"Failed to read pump state at address {coil_addr}", alarm=True)
                
        except Exception as e:
            self.log_message(f"Error toggling pump: {e}", alarm=True)
    
    def toggle_valve(self, tank_index):
        """
        Toggle tank fill valve state.
        
        Args:
            tank_index (int): Tank number (0-8)
        """
        try:
            coil_addr = COIL_FILL_START + tank_index
            
            # Read current state
            result = self.read_coils(coil_addr, 1)
            if result and not result.isError():
                current_state = result.bits[0]
                new_state = not current_state
                
                # Write new state
                if self.write_coil(coil_addr, new_state):
                    state_text = "OPEN" if new_state else "CLOSED"
                    self.log_message(f"Manual: Tank {tank_index + 1} valve {state_text}")
                else:
                    self.log_message(f"Failed to control Tank {tank_index + 1} valve", alarm=True)
            else:
                self.log_message(f"Failed to read Tank {tank_index + 1} valve state", alarm=True)
                
        except Exception as e:
            self.log_message(f"Error toggling valve: {e}", alarm=True)
    
    def emergency_stop(self):
        """Execute emergency stop - turn off all pumps and close all valves."""
        try:
            result = messagebox.askyesno(
                "Emergency Stop", 
                "Are you sure you want to execute Emergency Stop?\n\nThis will immediately turn off all pumps and close all valves.",
                icon='warning'
            )
            
            if result:
                # Turn off pumps
                self.write_coil(COIL_PUMP_LEAD, False)
                self.write_coil(COIL_PUMP_LAG, False)
                
                # Close all valves
                for i in range(NUM_TANKS):
                    self.write_coil(COIL_FILL_START + i, False)
                
                self.log_message("EMERGENCY STOP EXECUTED - All equipment shut down", alarm=True)
                
        except Exception as e:
            self.log_message(f"Error during emergency stop: {e}", alarm=True)
    
    def clear_alarms(self):
        """Clear all alarm messages from the log."""
        self.status_text.delete('1.0', tk.END)
        self.log_message("Alarms cleared by operator")
    
    def force_reconnect(self):
        """Force reconnection to PLC."""
        self.log_message("Manual reconnection requested")
        self.connected = False
        if self.client:
            self.client.close()
        self.initialize_client()
    
    def open_diagnostics(self):
        """Open diagnostics window with detailed system information."""
        diag_window = tk.Toplevel(self)
        diag_window.title("System Diagnostics")
        diag_window.geometry("800x600")
        diag_window.configure(bg="#f0f0f0")
        
        # Create notebook for tabbed interface
        notebook = ttk.Notebook(diag_window)
        notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Connection Tab
        conn_frame = ttk.Frame(notebook)
        notebook.add(conn_frame, text="Connection")
        
        conn_text = tk.Text(conn_frame, font=("Courier", 10))
        conn_text.pack(fill='both', expand=True, padx=5, pady=5)
        
        conn_info = f"""Connection Diagnostics:
        
PLC IP Address: {PLC_IP}
PLC Port: {PLC_PORT}
Connection Status: {'Connected' if self.connected else 'Disconnected'}
Connection Quality: {self.connection_quality}%
Reconnect Attempts: {self.reconnect_attempts}
Last Successful Read: {datetime.fromtimestamp(self.last_successful_read).strftime('%H:%M:%S')}
Watchdog Counter: {self.watchdog_counter}

Network Test: {'PASS' if self.validate_network_connection() else 'FAIL'}
        """
        
        conn_text.insert('1.0', conn_info)
        conn_text.config(state='disabled')
        
        # System Status Tab
        status_frame = ttk.Frame(notebook)
        notebook.add(status_frame, text="System Status")
        
        status_text = tk.Text(status_frame, font=("Courier", 10))
        status_text.pack(fill='both', expand=True, padx=5, pady=5)
        
        mode_names = ['OFF', 'HAND', 'AUTO']
        status_info = f"""System Status:
        
Current Mode: {mode_names[min(self.mode, 2)]}
System Status Flags: 0x{self.system_status:04X}
Main EPO Status: {'ACTIVE' if self.main_epo else 'OK'}

Tank Levels:
"""
        
        for i, level in enumerate(self.tank_levels):
            hh_status = "HH-ALARM" if self.hh_alarms[i] else "OK"
            epo_status = "EPO-ACTIVE" if self.epo_states[i] else "OK"
            valve_status = "OPEN" if self.valve_states[i] else "CLOSED"
            status_info += f"  Tank {i+1}: {level:.1f}% [{hh_status}] [{epo_status}] Valve: {valve_status}\n"

Pump Status:
  Pump 1: {'ON' if self.pump_states.get(COIL_PUMP_LEAD, False) else 'OFF'} - Runtime: {self.pump_runtimes[0]:.1f} hrs
  Pump 2: {'ON' if self.pump_states.get(COIL_PUMP_LAG, False) else 'OFF'} - Runtime: {self.pump_runtimes[1]:.1f} hrs

Flow Rates:
"""
        
        for i, flow in enumerate(self.flow_rates):
            status_info += f"  Flow {i+1}: {flow:.2f} GPM\n"
        
        status_text.insert('1.0', status_info)
        status_text.config(state='disabled')
        
        # Refresh button
        def refresh_diagnostics():
            conn_text.config(state='normal')
            status_text.config(state='normal')
            # Update connection info
            new_conn_info = f"""Connection Diagnostics:
        
PLC IP Address: {PLC_IP}
PLC Port: {PLC_PORT}
Connection Status: {'Connected' if self.connected else 'Disconnected'}
Connection Quality: {self.connection_quality}%
Reconnect Attempts: {self.reconnect_attempts}
Last Successful Read: {datetime.fromtimestamp(self.last_successful_read).strftime('%H:%M:%S')}
Watchdog Counter: {self.watchdog_counter}

Network Test: {'PASS' if self.validate_network_connection() else 'FAIL'}
            """
            conn_text.delete('1.0', tk.END)
            conn_text.insert('1.0', new_conn_info)
            conn_text.config(state='disabled')
            
            # Update status info - regenerate with current data
            new_status_info = f"""System Status:
        
Current Mode: {mode_names[min(self.mode, 2)]}
System Status Flags: 0x{self.system_status:04X}
Main EPO Status: {'ACTIVE' if self.main_epo else 'OK'}

Tank Levels:
"""
            for i, level in enumerate(self.tank_levels):
                hh_status = "HH-ALARM" if self.hh_alarms[i] else "OK"
                epo_status = "EPO-ACTIVE" if self.epo_states[i] else "OK"
                valve_status = "OPEN" if self.valve_states[i] else "CLOSED"
                new_status_info += f"  Tank {i+1}: {level:.1f}% [{hh_status}] [{epo_status}] Valve: {valve_status}\n"

            new_status_info += f"""
Pump Status:
  Pump 1: {'ON' if self.pump_states.get(COIL_PUMP_LEAD, False) else 'OFF'} - Runtime: {self.pump_runtimes[0]:.1f} hrs
  Pump 2: {'ON' if self.pump_states.get(COIL_PUMP_LAG, False) else 'OFF'} - Runtime: {self.pump_runtimes[1]:.1f} hrs

Flow Rates:
"""
            for i, flow in enumerate(self.flow_rates):
                new_status_info += f"  Flow {i+1}: {flow:.2f} GPM\n"
            
            status_text.delete('1.0', tk.END)
            status_text.insert('1.0', new_status_info)
            status_text.config(state='disabled')
        
        # Button frame
        btn_frame = tk.Frame(diag_window)
        btn_frame.pack(fill='x', padx=10, pady=5)
        
        tk.Button(
            btn_frame, 
            text="Refresh", 
            command=refresh_diagnostics,
            font=("Arial", 10)
        ).pack(side='left', padx=5)
        
        tk.Button(
            btn_frame, 
            text="Close", 
            command=diag_window.destroy,
            font=("Arial", 10)
        ).pack(side='right', padx=5)
    
    # =====================================================
    # DATA POLLING AND UPDATES
    # =====================================================
    
    def start_polling(self):
        """Start the data polling thread."""
        if self.poll_thread is None or not self.poll_thread.is_alive():
            self.polling = True
            self.poll_thread = threading.Thread(target=self.poll_data_worker, daemon=True)
            self.poll_thread.start()
            logger.info("Polling thread started")
        
        # Start GUI update timer
        self.after(100, self.update_gui)
    
    def poll_data_worker(self):
        """Main polling worker thread - runs continuously to read PLC data."""
        consecutive_failures = 0
        
        while self.polling:
            try:
                # Attempt connection if not connected
                if not self.connected:
                    if self.connect_with_retry():
                        consecutive_failures = 0
                        self.log_message("Connection established", warning=False)
                    else:
                        consecutive_failures += 1
                        if consecutive_failures % 10 == 1:  # Log every 10th failure
                            self.log_message(f"Connection failed ({consecutive_failures} attempts)", alarm=True)
                        time.sleep(POLLING_INTERVAL * 2)  # Longer delay when disconnected
                        continue
                
                # Poll all data
                self.poll_all_data()
                
                # Update connection quality
                self.last_successful_read = time.time()
                self.connection_quality = min(100, self.connection_quality + 2)
                consecutive_failures = 0
                
            except Exception as e:
                consecutive_failures += 1
                self.connection_quality = max(0, self.connection_quality - 10)
                logger.error(f"Polling error: {e}")
                
                if consecutive_failures > 5:
                    self.connected = False
                    self.log_message("Connection lost - attempting reconnection", warning=True)
            
            time.sleep(POLLING_INTERVAL)
    
    def poll_all_data(self):
        """Poll all data from PLC and update internal state."""
        data_update = {}
        
        # Read tank levels (Arduino stores as scaled integers * 100)
        tank_data = self.read_holding_registers(REG_LEVEL_START, NUM_TANKS)
        if tank_data and not tank_data.isError():
            # Convert from scaled integers back to percentages
            data_update['tank_levels'] = [reg / 100.0 for reg in tank_data.registers]
        
        # Read flow rates (Arduino stores as scaled integers * 100)
        flow_data = self.read_holding_registers(REG_FLOW_START, NUM_FLOWS)
        if flow_data and not flow_data.isError():
            # Convert from scaled integers back to GPM
            data_update['flow_rates'] = [reg / 100.0 for reg in flow_data.registers]
        
        # Read pump runtimes (Arduino stores as seconds)
        runtime_data = self.read_holding_registers(REG_PUMP_RUNTIME1, 2)
        if runtime_data and not runtime_data.isError():
            # Convert seconds to hours
            data_update['pump_runtimes'] = [reg / 3600.0 for reg in runtime_data.registers]
        
        # Read system mode
        mode_data = self.read_input_registers(REG_MODE_STATUS, 1)
        if mode_data and not mode_data.isError():
            data_update['mode'] = mode_data.registers[0]
        
        # Read watchdog counter
        watchdog_data = self.read_holding_registers(REG_WATCHDOG, 1)
        if watchdog_data and not watchdog_data.isError():
            data_update['watchdog'] = watchdog_data.registers[0]
        
        # Read system status
        status_data = self.read_holding_registers(REG_SYSTEM_STATUS, 1)
        if status_data and not status_data.isError():
            data_update['system_status'] = status_data.registers[0]
        
        # Read pump states
        pump_data = self.read_coils(COIL_PUMP_LEAD, 2)
        if pump_data and not pump_data.isError():
            data_update['pump_states'] = {
                COIL_PUMP_LEAD: pump_data.bits[0],
                COIL_PUMP_LAG: pump_data.bits[1]
            }
        
        # Read valve states
        valve_data = self.read_coils(COIL_FILL_START, NUM_TANKS)
        if valve_data and not valve_data.isError():
            data_update['valve_states'] = valve_data.bits[:NUM_TANKS]
        
        # Read High-High alarms
        hh_data = self.read_discrete_inputs(DISCRETE_HH_BASE, NUM_TANKS)
        if hh_data and not hh_data.isError():
            data_update['hh_alarms'] = hh_data.bits[:NUM_TANKS]
        
        # Read tank EPO states
        epo_data = self.read_discrete_inputs(DISCRETE_EPO_BASE, NUM_TANKS)
        if epo_data and not epo_data.isError():
            data_update['epo_states'] = epo_data.bits[:NUM_TANKS]
        
        # Read main EPO
        main_epo_data = self.read_discrete_inputs(DISCRETE_MAIN_EPO, 1)
        if main_epo_data and not main_epo_data.isError():
            data_update['main_epo'] = main_epo_data.bits[0]
        
        # Queue the update for the GUI thread
        try:
            self.data_queue.put(data_update, block=False)
        except queue.Full:
            pass  # Skip this update if queue is full
    
    def update_gui(self):
        """Update GUI with latest data from polling thread."""
        try:
            # Process all available data updates
            while not self.data_queue.empty():
                try:
                    data_update = self.data_queue.get_nowait()
                    self.process_data_update(data_update)
                except queue.Empty:
                    break
            
            # Update connection status display
            self.update_connection_display()
            
            # Validate data freshness
            self.validate_data_freshness()
            
        except Exception as e:
            logger.error(f"GUI update error: {e}")
        
        # Schedule next update
        if self.polling:
            self.after(100, self.update_gui)
    
    def process_data_update(self, data_update):
        """Process a single data update and refresh GUI elements."""
        
        # Update tank levels
        if 'tank_levels' in data_update:
            self.tank_levels = data_update['tank_levels']
            for i, level in enumerate(self.tank_levels):
                if i < len(self.tank_level_vars):
                    self.tank_level_vars[i].set(f"{level:.1f}%")
                    self.tank_level_bars[i]['value'] = level
        
        # Update flow rates
        if 'flow_rates' in data_update:
            self.flow_rates = data_update['flow_rates']
            for i, flow in enumerate(self.flow_rates):
                if i < len(self.flow_vars):
                    self.flow_vars[i].set(f"{flow:.2f} GPM")
        
        # Update pump runtimes
        if 'pump_runtimes' in data_update:
            self.pump_runtimes = data_update['pump_runtimes']
            for i, runtime in enumerate(self.pump_runtimes):
                if i < len(self.runtime_vars):
                    self.runtime_vars[i].set(f"{runtime:.1f} hrs")
        
        # Update system mode
        if 'mode' in data_update:
            self.mode = data_update['mode']
            mode_text = ['OFF', 'HAND', 'AUTO'][min(self.mode, 2)]
            self.mode_label.config(text=f"Mode: {mode_text}")
        
        # Update watchdog
        if 'watchdog' in data_update:
            current_watchdog = data_update['watchdog']
            if current_watchdog == self.last_watchdog and current_watchdog > 0:
                self.log_message("WARNING: PLC watchdog not updating!", warning=True)
            self.last_watchdog = current_watchdog
            self.watchdog_label.config(text=f"PLC: {current_watchdog}")
        
        # Update system status
        if 'system_status' in data_update:
            self.system_status = data_update['system_status']
            if self.system_status & 0x0001:  # Hardware fault bit
                self.log_message("SYSTEM FAULT: Hardware communication error!", alarm=True)
            if self.system_status & 0x0002:  # HMI timeout bit
                self.log_message("HMI communication timeout (info only)", warning=True)
        
        # Update pump button states
        if 'pump_states' in data_update:
            self.pump_states = data_update['pump_states']
            
            # Update pump 1 button
            pump1_on = self.pump_states.get(COIL_PUMP_LEAD, False)
            self.pump1_btn.config(
                text="Pump 1 ON" if pump1_on else "Pump 1 OFF",
                bg="#27ae60" if pump1_on else "#bdc3c7",
                fg="white" if pump1_on else "black"
            )
            
            # Update pump 2 button
            pump2_on = self.pump_states.get(COIL_PUMP_LAG, False)
            self.pump2_btn.config(
                text="Pump 2 ON" if pump2_on else "Pump 2 OFF",
                bg="#27ae60" if pump2_on else "#bdc3c7",
                fg="white" if pump2_on else "black"
            )
        
        # Update valve button states
        if 'valve_states' in data_update:
            self.valve_states = data_update['valve_states']
            for i, valve_open in enumerate(self.valve_states):
                if i < len(self.valve_btns):
                    self.valve_btns[i].config(
                        text=f"V{i+1}\n{'OPEN' if valve_open else 'CLOSED'}",
                        bg="#3498db" if valve_open else "#bdc3c7",
                        fg="white" if valve_open else "black"
                    )
        
        # Process High-High alarms
        if 'hh_alarms' in data_update:
            self.hh_alarms = data_update['hh_alarms']
            for i, hh_active in enumerate(self.hh_alarms):
                if hh_active and i < len(self.tank_status_labels):
                    self.tank_status_labels[i].config(text="HH-ALARM", fg="red")
                    self.log_message(f"HIGH-HIGH ALARM: Tank {i+1}", alarm=True)
                elif i < len(self.tank_status_labels):
                    # Check if tank is filling
                    filling = i < len(self.valve_states) and self.valve_states[i]
                    if filling:
                        self.tank_status_labels[i].config(text="FILLING", fg="blue")
                    else:
                        self.tank_status_labels[i].config(text="OK", fg="green")
        
        # Process tank EPO states
        if 'epo_states' in data_update:
            self.epo_states = data_update['epo_states']
            for i, epo_active in enumerate(self.epo_states):
                if epo_active:
                    self.log_message(f"EPO ACTIVE: Tank {i+1}", alarm=True)
        
        # Process main EPO
        if 'main_epo' in data_update:
            self.main_epo = data_update['main_epo']
            if self.main_epo:
                self.epo_label.config(text="EPO: ACTIVE", fg="red")
                self.log_message("MAIN EPO ACTIVATED - System shutdown!", alarm=True)
            else:
                self.epo_label.config(text="EPO: OK", fg="white")
    
    def update_connection_display(self):
        """Update connection status indicators in the header."""
        if self.connected:
            self.conn_label.config(text="Connected", fg="green")
        else:
            self.conn_label.config(text="Disconnected", fg="red")
        
        self.quality_label.config(text=f"Quality: {self.connection_quality}%")
        
        # Update quality color
        if self.connection_quality >= 80:
            quality_color = "green"
        elif self.connection_quality >= 50:
            quality_color = "orange"
        else:
            quality_color = "red"
        self.quality_label.config(fg=quality_color)
    
    def validate_data_freshness(self):
        """Check if received data is fresh and not stale."""
        current_time = time.time()
        if current_time - self.last_successful_read > 5.0:  # 5 seconds
            self.stale_data_count += 1
            if self.stale_data_count > 10:  # 10 consecutive stale readings
                self.log_message("WARNING: Data appears stale - check PLC connection", warning=True)
                self.stale_data_count = 0  # Reset counter
        else:
            self.stale_data_count = 0
    
    def on_closing(self):
        """Handle application closing."""
        try:
            self.log_message("HMI application shutting down")
            self.polling = False
            
            # Wait for polling thread to finish
            if self.poll_thread and self.poll_thread.is_alive():
                self.poll_thread.join(timeout=2)
            
            # Close Modbus client
            if self.client:
                self.client.close()
            
            logger.info("HMI Application closed cleanly")
            
        except Exception as e:
            logger.error(f"Error during shutdown: {e}")
        finally:
            self.destroy()

# =====================================================
# MAIN APPLICATION ENTRY POINT
# =====================================================

def main():
    """Main application entry point."""
    try:
        app = EnhancedHMIApp()
        app.mainloop()
    except Exception as e:
        logger.error(f"Fatal error in main application: {e}")
        messagebox.showerror("Fatal Error", f"Application failed to start:\n{e}")

if __name__ == "__main__":
    main()
