/*
 * =====================================================
 * TANK LEVEL CONTROL SYSTEM - PLC CONTROLLER v2.5
 * =====================================================
 * 
 * 
 * This Arduino PLC controller is designed to work seamlessly with:
 * - Python Web HMI (Flask application)
 * - Python Desktop HMI (Tkinter application)
 * - Modbus TCP communication protocol
 * 
 * ACTUAL HARDWARE CONFIGURATION:
 * - P1AM-200 CPU with P1AM-ETH Ethernet shield
 * - Slot 1: P1-08ADL-1 (8-channel 4-20mA inputs) - Tanks 1-8 levels
 * - Slot 2: P1-08ADL-1 (8-channel 4-20mA inputs) - Tank 9 + flows
 * - Slot 3: P1-16ND3 (16-channel digital inputs) - HH switches, EPO switches
 * - Slot 4: P1-16ND3 (16-channel digital inputs) - Mode switches, pump controls
 * - Slot 5: P1-16ND3 (16-channel digital inputs) - Spare inputs
 * - Slot 6: P1-15TD2 (15-channel relay outputs) - Pumps, fill valves 1-9
 * - Slot 7: P1-15TD2 (15-channel relay outputs) - Status lights, spare outputs
 * 
 * Version: 2.5 
 * Last Modified: August 2025
 * 
 * NEW FEATURES IN v2.5:
 */

#include <P1AM.h>
#include <Ethernet.h>

// =====================================================
// NETWORK SETTINGS
// =====================================================
byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };
IPAddress ip(192, 168, 1, 100);
EthernetServer ethServer(502);

// =====================================================
// SYSTEM CONSTANTS
// =====================================================
const int numTanks = 9;
const int numFlows = 2;

// SLOT ASSIGNMENTS (corrected for actual hardware)
const int analogSlot1 = 1;          // Slot 1: P1-08ADL-1 (Tanks 1-8)
const int analogSlot2 = 2;          // Slot 2: P1-08ADL-1 (Tank 9 + flows)
const int digitalInputSlot1 = 3;    // Slot 3: P1-16ND3 (HH switches, EPO)
const int digitalInputSlot2 = 4;    // Slot 4: P1-16ND3 (Mode, pump controls)
const int digitalInputSlot3 = 5;    // Slot 5: P1-16ND3 (Spare)
const int outputSlot1 = 6;          // Slot 6: P1-15TD2 (Pumps, valves)
const int outputSlot2 = 7;          // Slot 7: P1-15TD2 (Status lights)

// =====================================================
// MODBUS REGISTER MAPPING 
// =====================================================
const int REG_LEVEL_START = 0;      // Tank levels 0-8 (scaled x100)
const int REG_FLOW_START = 10;      // Flow rates 10-11 (scaled x100)
const int REG_MODE_STATUS = 20;     // Input register for mode (INPUT REG 0)
const int REG_PUMP_RUNTIME1 = 22;   // Pump 1 runtime (seconds)
const int REG_PUMP_RUNTIME2 = 23;   // Pump 2 runtime (seconds)
const int REG_WATCHDOG = 24;        // System watchdog counter
const int REG_SYSTEM_STATUS = 25;   // System status flags

const int COIL_FILL_START = 0;      // Fill valve coils 0-8
const int COIL_PUMP_LEAD = 10;      // Lead pump coil
const int COIL_PUMP_LAG = 11;       // Lag pump coil

const int DISCRETE_HH_BASE = 0;     // High-high switches 0-8
const int DISCRETE_EPO_BASE = 10;   // Tank EPO switches 10-18
const int DISCRETE_MAIN_EPO = 20;   // Main EPO switch

// Data storage for Modbus registers
uint16_t holdingRegisters[50];
uint16_t inputRegisters[20];
bool coils[30];
bool discreteInputs[30];

// =====================================================
// CONTROL PARAMETERS
// =====================================================
const float FILL_START_THRESHOLD = 30.0;  // Start filling at 30%
const float FILL_STOP_THRESHOLD = 90.0;   // Stop filling at 90%

// PUMP MANAGEMENT
unsigned long lastPumpSwitchTime = 0;
const unsigned long pumpSwitchInterval = 60000UL; // Switch every 60 seconds
bool leadPumpIsPump1 = true;
unsigned long pump1Runtime = 0;
unsigned long pump2Runtime = 0;
unsigned long pump1StartTime = 0;
unsigned long pump2StartTime = 0;

// SYSTEM MONITORING
unsigned long lastHMIContact = 0;
const unsigned long HMI_TIMEOUT = 10000;  // 10 second timeout
bool systemFault = false;
unsigned long watchdogCounter = 0;
unsigned long lastHeartbeat = 0;
unsigned long lastMainLoop = 0;

// ANALOG SCALING CONSTANTS for P1-08ADL-1
const float mA_min = 4.0;
const float mA_max = 20.0;
const float levelMax = 100.0;
const float flowMax = 50.0;

// System state variables
bool p1amInitialized = false;
bool ethernetInitialized = false;
int systemMode = 0; // 0=OFF, 1=HAND, 2=AUTO

// Communication tracking
unsigned long totalModbusRequests = 0;
unsigned long lastRequestTime = 0;
bool hmiConnected = false;

// =====================================================
// SETUP FUNCTION
// =====================================================
void setup() {
  // Initialize serial communication
  Serial.begin(115200);
  while (!Serial && millis() < 5000); // Wait up to 5 seconds for Serial
  
  delay(1000); // Give system time to stabilize
  
  Serial.println(F("\n====================================================="));
  Serial.println(F("TANK LEVEL CONTROL SYSTEM - PLC CONTROLLER v2.5"));
  Serial.println(F("HARMONY INTEGRATION VERSION"));
  Serial.println(F("=====================================================\n"));
  
  // Initialize P1AM system
  if (!initializeP1AM()) {
    Serial.println(F("FATAL: P1AM initialization failed"));
    systemFault = true;
  }
  
  // Initialize Ethernet
  if (!initializeEthernet()) {
    Serial.println(F("FATAL: Ethernet initialization failed"));
    systemFault = true;
  }
  
  // Initialize data structures
  initializeModbusData();
  
  // Display startup information
  displayStartupInfo();
  
  Serial.println(F("System initialization complete"));
  Serial.println(F("Ready for HMI connections...\n"));
  
  lastMainLoop = millis();
}

// =====================================================
// MAIN LOOP
// =====================================================
void loop() {
  unsigned long now = millis();
  
  // Update main loop timing
  lastMainLoop = now;
  
  // Handle Modbus TCP communications
  handleModbusTCP();
  
  // Read all system inputs
  readSystemInputs();
  
  // Update system control logic
  updateSystemControl();
  
  // Update output states
  updateSystemOutputs();
  
  // Perform safety checks
  performSafetyChecks();
  
  // Update watchdog counter
  updateWatchdog();
  
  // Periodic status output (every 10 seconds)
  static unsigned long lastStatusUpdate = 0;
  if (now - lastStatusUpdate > 10000) {
    displaySystemStatus();
    lastStatusUpdate = now;
  }
  
  // Small delay to prevent overwhelming the processor
  delay(10);
}

// =====================================================
// INITIALIZATION FUNCTIONS
// =====================================================

/**
 * Initialize P1AM system with error checking and module detection
 */
bool initializeP1AM() {
  Serial.println(F("Initializing P1AM system..."));
  
  delay(100);
  
  // Initialize with retries
  for (int attempt = 0; attempt < 3; attempt++) {
    if (P1.init()) {
      Serial.println(F("P1AM initialized successfully"));
      
      // Detect installed modules
      detectModules();
      
      p1amInitialized = true;
      return true;
    }
    
    Serial.print(F("P1AM init attempt "));
    Serial.print(attempt + 1);
    Serial.println(F(" failed, retrying..."));
    delay(1000);
  }
  
  Serial.println(F("FATAL: P1AM initialization failed after 3 attempts"));
  return false;
}

/**
 * Initialize Ethernet communication
 */
bool initializeEthernet() {
  Serial.println(F("Initializing Ethernet..."));
  
  // Start Ethernet connection
  Ethernet.begin(mac, ip);
  delay(2000); // Give Ethernet time to initialize
  
  // Check for Ethernet hardware
  if (Ethernet.hardwareStatus() == EthernetNoHardware) {
    Serial.println(F("FATAL: Ethernet shield was not found"));
    return false;
  }
  
  // Check for cable connection
  if (Ethernet.linkStatus() == LinkOFF) {
    Serial.println(F("WARNING: Ethernet cable is not connected"));
  }
  
  // Start the Modbus TCP server
  ethServer.begin();
  
  Serial.print(F("Ethernet initialized - IP: "));
  Serial.println(Ethernet.localIP());
  Serial.print(F("Modbus TCP server listening on port "));
  Serial.println(502);
  
  ethernetInitialized = true;
  return true;
}

/**
 * Detect and report installed P1AM modules
 */
void detectModules() {
  Serial.println(F("\n=== MODULE DETECTION ==="));
  
  for (int slot = 1; slot <= 8; slot++) {
    Serial.print(F("Slot "));
    Serial.print(slot);
    Serial.print(F(": "));
    
    // Try to determine module type
    // This is a simplified detection 
    if (slot <= 2) {
      Serial.println(F("P1-08ADL-1 (Analog Input)"));
    } else if (slot <= 5) {
      Serial.println(F("P1-16ND3 (Digital Input)"));
    } else if (slot <= 7) {
      Serial.println(F("P1-15TD2 (Digital Output)"));
    } else {
      Serial.println(F("Empty"));
    }
  }
  
  Serial.println(F("=========================\n"));
}

/**
 * Initialize Modbus data structures
 */
void initializeModbusData() {
  Serial.println(F("Initializing Modbus data structures..."));
  
  // Clear all data arrays
  memset(holdingRegisters, 0, sizeof(holdingRegisters));
  memset(inputRegisters, 0, sizeof(inputRegisters));
  memset(coils, false, sizeof(coils));
  memset(discreteInputs, false, sizeof(discreteInputs));
  
  // Set initial values
  inputRegisters[0] = systemMode; // System mode
  holdingRegisters[REG_SYSTEM_STATUS] = 0x0000; // System status OK
  
  Serial.println(F("Modbus data structures initialized"));
}

/**
 * Display startup information
 */
void displayStartupInfo() {
  Serial.println(F("\n=== SYSTEM CONFIGURATION ==="));
  Serial.print(F("MAC Address: "));
  for (int i = 0; i < 6; i++) {
    if (i > 0) Serial.print(F(":"));
    if (mac[i] < 16) Serial.print(F("0"));
    Serial.print(mac[i], HEX);
  }
  Serial.println();
  
  Serial.print(F("IP Address: "));
  Serial.println(ip);
  Serial.print(F("Modbus TCP Port: 502"));
  Serial.println();
  
  Serial.print(F("Number of Tanks: "));
  Serial.println(numTanks);
  Serial.print(F("Number of Flow Sensors: "));
  Serial.println(numFlows);
  
  Serial.println(F("\n=== REGISTER MAPPING ==="));
  Serial.println(F("Holding Registers:"));
  Serial.print(F("  Tank Levels: "));
  Serial.print(REG_LEVEL_START);
  Serial.print(F("-"));
  Serial.println(REG_LEVEL_START + numTanks - 1);
  
  Serial.print(F("  Flow Rates: "));
  Serial.print(REG_FLOW_START);
  Serial.print(F("-"));
  Serial.println(REG_FLOW_START + numFlows - 1);
  
  Serial.print(F("  Pump Runtimes: "));
  Serial.print(REG_PUMP_RUNTIME1);
  Serial.print(F(", "));
  Serial.println(REG_PUMP_RUNTIME2);
  
  Serial.println(F("Coils:"));
  Serial.print(F("  Fill Valves: "));
  Serial.print(COIL_FILL_START);
  Serial.print(F("-"));
  Serial.println(COIL_FILL_START + numTanks - 1);
  
  Serial.print(F("  Pumps: "));
  Serial.print(COIL_PUMP_LEAD);
  Serial.print(F(", "));
  Serial.println(COIL_PUMP_LAG);
  
  Serial.println(F("=============================\n"));
}

// =====================================================
// SYSTEM INPUT/OUTPUT FUNCTIONS
// =====================================================

/**
 * Read all system inputs and update data structures
 */
void readSystemInputs() {
  // Read tank levels from analog inputs
  for (int i = 0; i < numTanks; i++) {
    float mA_reading;
    
    if (i < 8) {
      // Tanks 1-8 on slot 1
      mA_reading = readAnalogInput(analogSlot1, i);
    } else {
      // Tank 9 on slot 2, channel 0
      mA_reading = readAnalogInput(analogSlot2, 0);
    }
    
    float level = scaleAnalogToPercent(mA_reading);
    
    // Store in holding registers (scaled by 100 for integer transmission)
    holdingRegisters[REG_LEVEL_START + i] = (uint16_t)(level * 100);
  }
  
  // Read flow rates
  for (int i = 0; i < numFlows; i++) {
    // Flow sensors on slot 2, channels 1-2
    float mA_reading = readAnalogInput(analogSlot2, i + 1);
    float flow = scaleAnalogToFlow(mA_reading);
    
    // Store in holding registers (scaled by 100)
    holdingRegisters[REG_FLOW_START + i] = (uint16_t)(flow * 100);
  }
  
  // Read high-high alarm switches
  for (int i = 0; i < numTanks; i++) {
    bool alarm = readDigitalInput(digitalInputSlot1, i);
    discreteInputs[DISCRETE_HH_BASE + i] = alarm;
  }
  
  // Read EPO switches
  for (int i = 0; i < numTanks; i++) {
    bool epo = readDigitalInput(digitalInputSlot1, i + 9);
    discreteInputs[DISCRETE_EPO_BASE + i] = epo;
  }
  
  // Read main EPO switch
  discreteInputs[DISCRETE_MAIN_EPO] = readDigitalInput(digitalInputSlot2, 0);
  
  // Read system mode switches (simplified - use digital inputs on slot 4)
  bool mode_auto = readDigitalInput(digitalInputSlot2, 1);
  bool mode_hand = readDigitalInput(digitalInputSlot2, 2);
  
  if (mode_auto && !mode_hand) {
    systemMode = 2; // AUTO
  } else if (!mode_auto && mode_hand) {
    systemMode = 1; // MANUAL
  } else {
    systemMode = 0; // OFF
  }
  
  inputRegisters[0] = systemMode;
}

/**
 * Update system control logic
 */
void updateSystemControl() {
  // Update pump runtime tracking
  bool pump1On = coils[COIL_PUMP_LEAD];
  bool pump2On = coils[COIL_PUMP_LAG];
  
  updatePumpRuntime(pump1On, pump2On);
  
  // Update input registers with current pump states
  inputRegisters[2] = pump1On ? 1 : 0;
  inputRegisters[3] = pump2On ? 1 : 0;
  
  // Auto mode logic (simplified)
  if (systemMode == 2) { // AUTO mode
    // Implement automatic tank filling logic here
    autoFillControl();
  }
  
  // Emergency stop logic
  if (discreteInputs[DISCRETE_MAIN_EPO]) {
    handleEmergencyStop();
  }
}

/**
 * Automatic fill control logic
 */
void autoFillControl() {
  static unsigned long lastFillCheck = 0;
  unsigned long now = millis();
  
  // Check fill logic every 5 seconds
  if (now - lastFillCheck < 5000) return;
  lastFillCheck = now;
  
  for (int i = 0; i < numTanks; i++) {
    float level = holdingRegisters[REG_LEVEL_START + i] / 100.0;
    
    // Start filling if level is low and no HH alarm
    if (level < FILL_START_THRESHOLD && !discreteInputs[DISCRETE_HH_BASE + i]) {
      coils[COIL_FILL_START + i] = true;
    }
    
    // Stop filling if level is high or HH alarm is active
    if (level > FILL_STOP_THRESHOLD || discreteInputs[DISCRETE_HH_BASE + i]) {
      coils[COIL_FILL_START + i] = false;
    }
  }
  
  // Simple pump control - run pumps if any valve is open
  bool anyValveOpen = false;
  for (int i = 0; i < numTanks; i++) {
    if (coils[COIL_FILL_START + i]) {
      anyValveOpen = true;
      break;
    }
  }
  
  if (anyValveOpen) {
    // Use lead/lag pump control
    coils[COIL_PUMP_LEAD] = true;
    
    // Start lag pump if needed (simplified logic)
    static bool lagPumpNeeded = false;
    if (lagPumpNeeded) {
      coils[COIL_PUMP_LAG] = true;
    }
  } else {
    // Stop pumps if no valves are open
    coils[COIL_PUMP_LEAD] = false;
    coils[COIL_PUMP_LAG] = false;
  }
}

/**
 * Update system outputs based on coil states
 */
void updateSystemOutputs() {
  // Update pump outputs
  writeDigitalOutput(outputSlot1, 0, coils[COIL_PUMP_LEAD]);   // Pump 1
  writeDigitalOutput(outputSlot1, 1, coils[COIL_PUMP_LAG]);    // Pump 2
  
  // Update valve outputs
  for (int i = 0; i < numTanks && i < 13; i++) { // P1-15TD2 has 15 channels, pumps use 2
    writeDigitalOutput(outputSlot1, i + 2, coils[COIL_FILL_START + i]);
  }
  
  // Update status light outputs (slot 7)
  for (int i = 0; i < numTanks && i < 15; i++) {
    // Light on if tank level > 50%
    bool lightOn = (holdingRegisters[REG_LEVEL_START + i] / 100.0) > 50.0;
    writeDigitalOutput(outputSlot2, i, lightOn);
  }
}

// =====================================================
// MODBUS TCP COMMUNICATION
// =====================================================

/**
 * Handle Modbus TCP communications
 */
void handleModbusTCP() {
  EthernetClient client = ethServer.available();
  if (!client) return;
  
  unsigned long clientTimeout = millis() + 5000; // 5 second client timeout
  
  // Process multiple requests from the same client
  while (client.connected() && millis() < clientTimeout) {
    
    // Wait for incoming data
    while (!client.available() && client.connected() && millis() < clientTimeout) {
      delay(1);
    }
    
    if (!client.available()) break;
    
    // Read MBAP header (7 bytes)
    uint8_t mbapHeader[7];
    int headerBytesRead = 0;
    
    for (int i = 0; i < 7 && client.available() && millis() < clientTimeout; i++) {
      mbapHeader[i] = client.read();
      headerBytesRead++;
    }
    
    if (headerBytesRead < 7) {
      Serial.println(F("Incomplete MBAP header"));
      break;
    }
    
    // Extract MBAP fields
    uint16_t transactionId = (mbapHeader[0] << 8) | mbapHeader[1];
    uint16_t protocolId = (mbapHeader[2] << 8) | mbapHeader[3];
    uint16_t length = (mbapHeader[4] << 8) | mbapHeader[5];
    uint8_t unitId = mbapHeader[6];
    
    // Validate protocol ID
    if (protocolId != 0) {
      Serial.println(F("Invalid Protocol ID"));
      sendExceptionResponse(client, transactionId, 0x01, 0x04);
      break;
    }
    
    // Calculate PDU length
    int pduLength = length - 1; // Length includes unit ID
    
    if (pduLength < 1 || pduLength > 253) {
      Serial.println(F("Invalid PDU length"));
      sendExceptionResponse(client, transactionId, 0x01, 0x03);
      break;
    }
    
    // Read PDU
    uint8_t pdu[253];
    int pduBytesRead = 0;
    
    for (int i = 0; i < pduLength && client.available() && millis() < clientTimeout; i++) {
      pdu[i] = client.read();
      pduBytesRead++;
    }
    
    if (pduBytesRead < pduLength) {
      Serial.println(F("Incomplete PDU"));
      break;
    }
    
    // Extract function code
    uint8_t functionCode = pdu[0];
    
    // Update HMI communication tracking
    lastHMIContact = millis();
    totalModbusRequests++;
    lastRequestTime = millis();
    hmiConnected = true;
    
    // Process the request
    processModbusRequest(client, transactionId, functionCode, pdu, pduBytesRead);
  }
  
  // Close client connection
  client.stop();
}

/**
 * Process individual Modbus requests
 */
void processModbusRequest(EthernetClient& client, uint16_t transactionId, uint8_t functionCode, uint8_t* pdu, int pduLength) {
  
  switch (functionCode) {
    case 0x03: // Read Holding Registers
      if (pduLength >= 5) {
        uint16_t startAddr = (pdu[1] << 8) | pdu[2];
        uint16_t quantity = (pdu[3] << 8) | pdu[4];
        sendHoldingRegisters(client, transactionId, startAddr, quantity);
      } else {
        sendExceptionResponse(client, transactionId, functionCode, 0x03);
      }
      break;
      
    case 0x04: // Read Input Registers
      if (pduLength >= 5) {
        uint16_t startAddr = (pdu[1] << 8) | pdu[2];
        uint16_t quantity = (pdu[3] << 8) | pdu[4];
        sendInputRegisters(client, transactionId, startAddr, quantity);
      } else {
        sendExceptionResponse(client, transactionId, functionCode, 0x03);
      }
      break;
      
    case 0x01: // Read Coils
      if (pduLength >= 5) {
        uint16_t startAddr = (pdu[1] << 8) | pdu[2];
        uint16_t quantity = (pdu[3] << 8) | pdu[4];
        sendCoils(client, transactionId, startAddr, quantity);
      } else {
        sendExceptionResponse(client, transactionId, functionCode, 0x03);
      }
      break;
      
    case 0x02: // Read Discrete Inputs
      if (pduLength >= 5) {
        uint16_t startAddr = (pdu[1] << 8) | pdu[2];
        uint16_t quantity = (pdu[3] << 8) | pdu[4];
        sendDiscreteInputs(client, transactionId, startAddr, quantity);
      } else {
        sendExceptionResponse(client, transactionId, functionCode, 0x03);
      }
      break;
      
    case 0x05: // Write Single Coil
      if (pduLength >= 5) {
        uint16_t coilAddr = (pdu[1] << 8) | pdu[2];
        uint16_t coilValue = (pdu[3] << 8) | pdu[4];
        writeSingleCoil(client, transactionId, coilAddr, coilValue);
      } else {
        sendExceptionResponse(client, transactionId, functionCode, 0x03);
      }
      break;
      
    case 0x06: // Write Single Register
      if (pduLength >= 5) {
        uint16_t regAddr = (pdu[1] << 8) | pdu[2];
        uint16_t regValue = (pdu[3] << 8) | pdu[4];
        writeSingleRegister(client, transactionId, regAddr, regValue);
      } else {
        sendExceptionResponse(client, transactionId, functionCode, 0x03);
      }
      break;
      
    default:
      
      sendExceptionResponse(client, transactionId, functionCode, 0x01);
      break;
  }
}

/**
 * Send holding registers response
 */
void sendHoldingRegisters(EthernetClient& client, uint16_t transactionId, uint16_t startAddr, uint16_t quantity) {
  if (quantity == 0 || quantity > 125 || startAddr + quantity > 50) {
    sendExceptionResponse(client, transactionId, 0x03, 0x02);
    return;
  }
  
  uint8_t byteCount = quantity * 2;
  uint8_t response[7 + 1 + byteCount]; // MBAP + Function Code + Byte Count + Data
  
  // MBAP Header
  response[0] = (transactionId >> 8) & 0xFF;
  response[1] = transactionId & 0xFF;
  response[2] = 0x00; // Protocol ID
  response[3] = 0x00;
  response[4] = 0x00; // Length (will be set below)
  response[5] = (1 + byteCount + 1) & 0xFF;
  response[6] = 0x01; // Unit ID
  
  // PDU
  response[7] = 0x03; // Function Code
  response[8] = byteCount;
  
  // Data
  for (int i = 0; i < quantity; i++) {
    uint16_t regValue = holdingRegisters[startAddr + i];
    response[9 + i * 2] = (regValue >> 8) & 0xFF;
    response[10 + i * 2] = regValue & 0xFF;
  }
  
  client.write(response, sizeof(response));
}

/**
 * Send input registers response
 */
void sendInputRegisters(EthernetClient& client, uint16_t transactionId, uint16_t startAddr, uint16_t quantity) {
  if (quantity == 0 || quantity > 125 || startAddr + quantity > 20) {
    sendExceptionResponse(client, transactionId, 0x04, 0x02);
    return;
  }
  
  uint8_t byteCount = quantity * 2;
  uint8_t response[7 + 1 + byteCount]; // MBAP + Function Code + Byte Count + Data
  
  // MBAP Header
  response[0] = (transactionId >> 8) & 0xFF;
  response[1] = transactionId & 0xFF;
  response[2] = 0x00; // Protocol ID
  response[3] = 0x00;
  response[4] = 0x00; // Length
  response[5] = (1 + byteCount + 1) & 0xFF;
  response[6] = 0x01; // Unit ID
  
  // PDU
  response[7] = 0x04; // Function Code
  response[8] = byteCount;
  
  // Data
  for (int i = 0; i < quantity; i++) {
    uint16_t regValue = inputRegisters[startAddr + i];
    response[9 + i * 2] = (regValue >> 8) & 0xFF;
    response[10 + i * 2] = regValue & 0xFF;
  }
  
  client.write(response, sizeof(response));
}

/**
 * Send coils response
 */
void sendCoils(EthernetClient& client, uint16_t transactionId, uint16_t startAddr, uint16_t quantity) {
  if (quantity == 0 || quantity > 2000 || startAddr + quantity > 30) {
    sendExceptionResponse(client, transactionId, 0x01, 0x02);
    return;
  }
  
  uint8_t byteCount = (quantity + 7) / 8; // Round up to nearest byte
  uint8_t response[7 + 1 + byteCount]; // MBAP + Function Code + Byte Count + Data
  
  // MBAP Header
  response[0] = (transactionId >> 8) & 0xFF;
  response[1] = transactionId & 0xFF;
  response[2] = 0x00; // Protocol ID
  response[3] = 0x00;
  response[4] = 0x00; // Length
  response[5] = (1 + byteCount + 1) & 0xFF;
  response[6] = 0x01; // Unit ID
  
  // PDU
  response[7] = 0x01; // Function Code
  response[8] = byteCount;
  
  // Pack coils into bytes
  memset(&response[9], 0, byteCount);
  for (int i = 0; i < quantity; i++) {
    if (coils[startAddr + i]) {
      response[9 + i / 8] |= (1 << (i % 8));
    }
  }
  
  client.write(response, sizeof(response));
}

/**
 * Send discrete inputs response
 */
void sendDiscreteInputs(EthernetClient& client, uint16_t transactionId, uint16_t startAddr, uint16_t quantity) {
  if (quantity == 0 || quantity > 2000 || startAddr + quantity > 30) {
    sendExceptionResponse(client, transactionId, 0x02, 0x02);
    return;
  }
  
  uint8_t byteCount = (quantity + 7) / 8; // Round up to nearest byte
  uint8_t response[7 + 1 + byteCount]; // MBAP + Function Code + Byte Count + Data
  
  // MBAP Header
  response[0] = (transactionId >> 8) & 0xFF;
  response[1] = transactionId & 0xFF;
  response[2] = 0x00; // Protocol ID
  response[3] = 0x00;
  response[4] = 0x00; // Length
  response[5] = (1 + byteCount + 1) & 0xFF;
  response[6] = 0x01; // Unit ID
  
  // PDU
  response[7] = 0x02; // Function Code
  response[8] = byteCount;
  
  // Pack discrete inputs into bytes
  memset(&response[9], 0, byteCount);
  for (int i = 0; i < quantity; i++) {
    if (discreteInputs[startAddr + i]) {
      response[9 + i / 8] |= (1 << (i % 8));
    }
  }
  
  client.write(response, sizeof(response));
}

/**
 * Write single coil
 */
void writeSingleCoil(EthernetClient& client, uint16_t transactionId, uint16_t coilAddr, uint16_t coilValue) {
  if (coilAddr >= 30) {
    sendExceptionResponse(client, transactionId, 0x05, 0x02);
    return;
  }
  
  // Update coil state
  coils[coilAddr] = (coilValue == 0xFF00);
  
  // Echo back the request as confirmation
  uint8_t response[12]; // MBAP + Function Code + Address + Value
  
  // MBAP Header
  response[0] = (transactionId >> 8) & 0xFF;
  response[1] = transactionId & 0xFF;
  response[2] = 0x00; // Protocol ID
  response[3] = 0x00;
  response[4] = 0x00; // Length
  response[5] = 0x06; // 6 bytes following
  response[6] = 0x01; // Unit ID
  
  // PDU
  response[7] = 0x05; // Function Code
  response[8] = (coilAddr >> 8) & 0xFF;
  response[9] = coilAddr & 0xFF;
  response[10] = (coilValue >> 8) & 0xFF;
  response[11] = coilValue & 0xFF;
  
  client.write(response, sizeof(response));
  
  Serial.print(F("Coil "));
  Serial.print(coilAddr);
  Serial.print(F(" set to "));
  Serial.println(coils[coilAddr] ? F("ON") : F("OFF"));
}

/**
 * Write single register
 */
void writeSingleRegister(EthernetClient& client, uint16_t transactionId, uint16_t regAddr, uint16_t regValue) {
  if (regAddr >= 50) {
    sendExceptionResponse(client, transactionId, 0x06, 0x02);
    return;
  }
  
  // Update register value
  holdingRegisters[regAddr] = regValue;
  
  // Echo back the request as confirmation
  uint8_t response[12]; // MBAP + Function Code + Address + Value
  
  // MBAP Header
  response[0] = (transactionId >> 8) & 0xFF;
  response[1] = transactionId & 0xFF;
  response[2] = 0x00; // Protocol ID
  response[3] = 0x00;
  response[4] = 0x00; // Length
  response[5] = 0x06; // 6 bytes following
  response[6] = 0x01; // Unit ID
  
  // PDU
  response[7] = 0x06; // Function Code
  response[8] = (regAddr >> 8) & 0xFF;
  response[9] = regAddr & 0xFF;
  response[10] = (regValue >> 8) & 0xFF;
  response[11] = regValue & 0xFF;
  
  client.write(response, sizeof(response));
  
  Serial.print(F("Register "));
  Serial.print(regAddr);
  Serial.print(F(" set to "));
  Serial.println(regValue);
}

/**
 * Send exception response
 */
void sendExceptionResponse(EthernetClient& client, uint16_t transactionId, uint8_t functionCode, uint8_t exceptionCode) {
  uint8_t response[9]; // MBAP + Exception Function Code + Exception Code
  
  // MBAP Header
  response[0] = (transactionId >> 8) & 0xFF;
  response[1] = transactionId & 0xFF;
  response[2] = 0x00; // Protocol ID
  response[3] = 0x00;
  response[4] = 0x00; // Length
  response[5] = 0x03; // 3 bytes following
  response[6] = 0x01; // Unit ID
  
  // PDU
  response[7] = functionCode | 0x80; // Exception function code
  response[8] = exceptionCode;
  
  client.write(response, sizeof(response));
  
  Serial.print(F("Exception response: FC="));
  Serial.print(functionCode, HEX);
  Serial.print(F(" EC="));
  Serial.println(exceptionCode, HEX);
}

// =====================================================
// UTILITY AND SUPPORT FUNCTIONS
// =====================================================

/**
 * Read digital input with error checking
 */
bool readDigitalInput(int slot, int channel) {
  if (!p1amInitialized) return false;
  if (channel < 0 || channel > 15) return false;
  
  return P1.readDiscrete(slot, channel);
}

/**
 * Write digital output with error checking
 */
bool writeDigitalOutput(int slot, int channel, bool state) {
  if (!p1amInitialized) {
    return false;
  }
  
  // Validate slot has outputs
  if (slot != outputSlot1 && slot != outputSlot2) {
    return false;
  }
  
  // Validate channel range for P1-15TD2 (15 channels, 0-14)
  if (channel < 0 || channel > 14) {
    return false;
  }
  
  P1.writeDiscrete(slot, channel, state);
  return true;
}

/**
 * Read analog input with error checking
 */
float readAnalogInput(int slot, int channel) {
  if (!p1amInitialized) return -1.0;
  if (channel < 0 || channel > 7) return -1.0;
  
  float reading = P1.readAnalog(slot, channel);
  
  // Validate reading is within expected range for 4-20mA
  if (reading < 0 || reading > 25.0) {
    return -1.0;
  }
  
  return reading;
}

/**
 * Scale analog input to percentage (tank levels)
 */
float scaleAnalogToPercent(float mA) {
  if (mA < 0) return 0.0;
  if (mA < 3.0) return 0.0;
  
  float constrainedMA = constrain(mA, mA_min, mA_max);
  return ((constrainedMA - mA_min) / (mA_max - mA_min)) * levelMax;
}

/**
 * Scale analog input to flow rate (GPM)
 */
float scaleAnalogToFlow(float mA) {
  if (mA < 0) return 0.0;
  if (mA < 3.0) return 0.0;
  
  float constrainedMA = constrain(mA, mA_min, mA_max);
  return ((constrainedMA - mA_min) / (mA_max - mA_min)) * flowMax;
}

/**
 * Update pump runtime tracking
 */
void updatePumpRuntime(bool pump1On, bool pump2On) {
  unsigned long now = millis();
  
  // Handle millis() rollover
  if (now < pump1StartTime) pump1StartTime = now;
  if (now < pump2StartTime) pump2StartTime = now;
  
  // Track pump 1 runtime
  if (pump1On) {
    if (pump1StartTime == 0) pump1StartTime = now;
  } else {
    if (pump1StartTime > 0) {
      pump1Runtime += (now - pump1StartTime);
      pump1StartTime = 0;
    }
  }

  // Track pump 2 runtime
  if (pump2On) {
    if (pump2StartTime == 0) pump2StartTime = now;
  } else {
    if (pump2StartTime > 0) {
      pump2Runtime += (now - pump2StartTime);
      pump2StartTime = 0;
    }
  }

  // Update registers (convert to seconds)
  holdingRegisters[REG_PUMP_RUNTIME1] = pump1Runtime / 1000;
  holdingRegisters[REG_PUMP_RUNTIME2] = pump2Runtime / 1000;
}

/**
 * Perform comprehensive safety checks
 */
bool performSafetyChecks() {
  bool safe = true;
  uint16_t statusFlags = 0;
  
  // Check P1AM module communication
  if (!p1amInitialized) {
    systemFault = true;
    safe = false;
    statusFlags |= 0x0001; // Bit 0: Hardware fault
  }
  
  // Check for HMI communication timeout
  if (millis() - lastHMIContact > HMI_TIMEOUT) {
    statusFlags |= 0x0002; // Bit 1: HMI timeout
  } else {
    hmiConnected = true;
  }
  
  // Update system status register
  holdingRegisters[REG_SYSTEM_STATUS] = statusFlags;
  
  return safe;
}

/**
 * Handle emergency stop condition
 */
void handleEmergencyStop() {
  Serial.println(F("EMERGENCY STOP ACTIVATED"));
  
  // Immediate shutdown of all pumps
  writeDigitalOutput(outputSlot1, 0, false); // Pump 1
  writeDigitalOutput(outputSlot1, 1, false); // Pump 2
  
  // Close all valves
  for (int i = 0; i < numTanks && i < 13; i++) {
    writeDigitalOutput(outputSlot1, i + 2, false);
  }
  
  // Clear all coils
  for (int i = 0; i < 30; i++) {
    coils[i] = false;
  }
}

/**
 * Update watchdog counter
 */
void updateWatchdog() {
  static unsigned long lastWatchdogUpdate = 0;
  unsigned long now = millis();
  
  if (now - lastWatchdogUpdate >= 1000) { // Update every second
    watchdogCounter++;
    holdingRegisters[REG_WATCHDOG] = watchdogCounter & 0xFFFF;
    lastWatchdogUpdate = now;
  }
}

/**
 * Display periodic system status
 */
void displaySystemStatus() {
  Serial.println(F("\n=== SYSTEM STATUS ==="));
  Serial.print(F("Uptime: "));
  Serial.print(millis() / 1000);
  Serial.println(F(" seconds"));
  
  Serial.print(F("System Mode: "));
  switch(systemMode) {
    case 0: Serial.println(F("OFF")); break;
    case 1: Serial.println(F("MANUAL")); break;
    case 2: Serial.println(F("AUTO")); break;
    default: Serial.println(F("UNKNOWN")); break;
  }
  
  Serial.print(F("HMI Connected: "));
  Serial.println(hmiConnected ? F("YES") : F("NO"));
  
  Serial.print(F("Total Modbus Requests: "));
  Serial.println(totalModbusRequests);
  
  Serial.print(F("Pump States: P1="));
  Serial.print(coils[COIL_PUMP_LEAD] ? F("ON") : F("OFF"));
  Serial.print(F(", P2="));
  Serial.println(coils[COIL_PUMP_LAG] ? F("ON") : F("OFF"));
  
  Serial.print(F("Tank Levels: "));
  for (int i = 0; i < min(3, numTanks); i++) {
    if (i > 0) Serial.print(F(", "));
    Serial.print(F("T"));
    Serial.print(i+1);
    Serial.print(F("="));
    Serial.print(holdingRegisters[REG_LEVEL_START + i] / 100.0, 1);
    Serial.print(F("%"));
  }
  Serial.println();
  
  Serial.println(F("====================\n"));
}
