#!/usr/bin/env python3
"""
STANDALONE TANK LEVEL CONTROL HMI
No external dependencies - uses only Python standard libraries
Perfect for air-gapped systems connected directly to PLC
"""

import tkinter as tk
from tkinter import ttk, messagebox
import socket
import struct
import threading
import time
import logging
from datetime import datetime
import json
import os

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('standalone_hmi.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class ModbusTCPClient:
    """Minimal Modbus TCP client using only standard library"""
    
    def __init__(self, host, port=502, unit_id=1, timeout=3):
        self.host = host
        self.port = port
        self.unit_id = unit_id
        self.timeout = timeout
        self.sock = None
        self.transaction_id = 1
        
    def connect(self):
        """Connect to Modbus TCP server"""
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(self.timeout)
            self.sock.connect((self.host, self.port))
            logger.info(f"Connected to {self.host}:{self.port}")
            return True
        except Exception as e:
            logger.error(f"Connection failed: {e}")
            if self.sock:
                self.sock.close()
                self.sock = None
            return False
    
    def disconnect(self):
        """Disconnect from Modbus TCP server"""
        if self.sock:
            self.sock.close()
            self.sock = None
    
    def is_connected(self):
        """Check if connected"""
        return self.sock is not None
    
    def _send_request(self, pdu):
        """Send Modbus TCP request"""
        if not self.sock:
            return None
            
        try:
            # MBAP Header: Transaction ID(2) + Protocol ID(2) + Length(2) + Unit ID(1)
            length = len(pdu) + 1  # PDU + Unit ID
            mbap = struct.pack('>HHHB', self.transaction_id, 0, length, self.unit_id)
            request = mbap + pdu
            
            self.sock.send(request)
            self.transaction_id = (self.transaction_id + 1) % 65536
            
            # Read response
            response = self.sock.recv(1024)
            if len(response) < 8:
                return None
                
            # Parse MBAP header
            trans_id, proto_id, length, unit_id = struct.unpack('>HHHB', response[:7])
            
            # Return PDU (response without MBAP header)
            return response[7:]
            
        except Exception as e:
            logger.error(f"Request failed: {e}")
            self.disconnect()
            return None
    
    def read_holding_registers(self, address, count):
        """Read holding registers (function code 3)"""
        if count > 125:
            raise ValueError("Cannot read more than 125 registers")
        
        # Function code 3, starting address, quantity
        pdu = struct.pack('>BHH', 3, address, count)
        response = self._send_request(pdu)
        
        if not response or len(response) < 2:
            return None
            
        func_code = response[0]
        if func_code & 0x80:  # Error response
            error_code = response[1]
            logger.error(f"Modbus error {error_code}")
            return None
            
        if func_code != 3:
            return None
            
        byte_count = response[1]
        if len(response) < 2 + byte_count:
            return None
            
        # Parse register values
        registers = []
        for i in range(0, byte_count, 2):
            value = struct.unpack('>H', response[2+i:4+i])[0]
            registers.append(value)
            
        return registers
    
    def read_coils(self, address, count):
        """Read coils (function code 1)"""
        if count > 2000:
            raise ValueError("Cannot read more than 2000 coils")
            
        pdu = struct.pack('>BHH', 1, address, count)
        response = self._send_request(pdu)
        
        if not response or len(response) < 2:
            return None
            
        func_code = response[0]
        if func_code & 0x80:
            return None
            
        if func_code != 1:
            return None
            
        byte_count = response[1]
        coil_data = response[2:2+byte_count]
        
        # Parse coil values
        coils = []
        for byte_val in coil_data:
            for bit in range(8):
                if len(coils) >= count:
                    break
                coils.append((byte_val >> bit) & 1 == 1)
        
        return coils[:count]
    
    def read_discrete_inputs(self, address, count):
        """Read discrete inputs (function code 2)"""
        if count > 2000:
            raise ValueError("Cannot read more than 2000 inputs")
            
        pdu = struct.pack('>BHH', 2, address, count)
        response = self._send_request(pdu)
        
        if not response or len(response) < 2:
            return None
            
        func_code = response[0]
        if func_code & 0x80:
            return None
            
        if func_code != 2:
            return None
            
        byte_count = response[1]
        input_data = response[2:2+byte_count]
        
        # Parse input values
        inputs = []
        for byte_val in input_data:
            for bit in range(8):
                if len(inputs) >= count:
                    break
                inputs.append((byte_val >> bit) & 1 == 1)
        
        return inputs[:count]
    
    def write_single_coil(self, address, value):
        """Write single coil (function code 5)"""
        coil_value = 0xFF00 if value else 0x0000
        pdu = struct.pack('>BHH', 5, address, coil_value)
        response = self._send_request(pdu)
        
        if not response:
            return False
            
        func_code = response[0]
        if func_code & 0x80:
            return False
            
        return func_code == 5

class StandaloneHMI:
    """Standalone HMI application - no external dependencies"""
    
    def __init__(self):
        # Configuration
        self.PLC_IP = "192.168.1.100"
        self.PLC_PORT = 502
        self.UNIT_ID = 1
        self.POLLING_INTERVAL = 2.0
        
        # Data storage
        self.tank_levels = [0.0] * 9
        self.flow_rates = [0.0, 0.0]
        self.pump_states = [False, False]
        self.valve_states = [False] * 9
        self.pump_runtimes = [0, 0]
        self.system_mode = 0  # 0=OFF, 1=MANUAL, 2=AUTO
        self.hh_alarms = [False] * 9
        self.main_epo = False
        
        # Connection status
        self.connected = False
        self.connection_quality = 0
        self.last_update = 0
        
        # Modbus client
        self.client = ModbusTCPClient(self.PLC_IP, self.PLC_PORT, self.UNIT_ID)
        
        # Threading
        self.running = True
        self.data_thread = None
        
        # Create GUI
        self.create_gui()
        
        # Start data polling
        self.start_data_polling()
        
        logger.info("Standalone HMI initialized")
    
    def create_gui(self):
        """Create the main GUI"""
        self.root = tk.Tk()
        self.root.title("Tank Level Control System - Standalone HMI")
        self.root.geometry("1200x800")
        self.root.protocol("WM_DELETE_WINDOW", self.on_closing)
        
        # Create notebook for tabs
        notebook = ttk.Notebook(self.root)
        notebook.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Overview Tab
        self.create_overview_tab(notebook)
        
        # Controls Tab
        self.create_controls_tab(notebook)
        
        # Diagnostics Tab
        self.create_diagnostics_tab(notebook)
        
        # Status bar
        self.create_status_bar()
        
        # Update display every second
        self.update_display()
    
    def create_overview_tab(self, notebook):
        """Create overview tab with tank displays"""
        overview_frame = ttk.Frame(notebook)
        notebook.add(overview_frame, text="System Overview")
        
        # Connection status
        conn_frame = ttk.LabelFrame(overview_frame, text="Connection Status")
        conn_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.conn_status_label = ttk.Label(conn_frame, text="Disconnected", foreground="red")
        self.conn_status_label.pack(side=tk.LEFT, padx=10, pady=5)
        
        self.quality_label = ttk.Label(conn_frame, text="Quality: 0%")
        self.quality_label.pack(side=tk.LEFT, padx=10, pady=5)
        
        self.last_update_label = ttk.Label(conn_frame, text="Last Update: Never")
        self.last_update_label.pack(side=tk.LEFT, padx=10, pady=5)
        
        # Tank displays
        tanks_frame = ttk.LabelFrame(overview_frame, text="Tank Levels")
        tanks_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        # Create 3x3 grid of tank displays
        self.tank_frames = []
        self.tank_labels = []
        self.level_bars = []
        
        for i in range(9):
            row = i // 3
            col = i % 3
            
            tank_frame = ttk.LabelFrame(tanks_frame, text=f"Tank {i+1}")
            tank_frame.grid(row=row, column=col, padx=5, pady=5, sticky="nsew")
            
            # Level display
            level_label = ttk.Label(tank_frame, text="0.0%", font=("Arial", 14, "bold"))
            level_label.pack(pady=5)
            
            # Progress bar for level
            level_bar = ttk.Progressbar(tank_frame, length=100, mode='determinate')
            level_bar.pack(pady=5)
            
            # Alarm indicator
            alarm_label = ttk.Label(tank_frame, text="OK", foreground="green")
            alarm_label.pack(pady=2)
            
            self.tank_frames.append(tank_frame)
            self.tank_labels.append(level_label)
            self.level_bars.append(level_bar)
        
        # Configure grid weights
        for i in range(3):
            tanks_frame.columnconfigure(i, weight=1)
            tanks_frame.rowconfigure(i, weight=1)
        
        # Flow and pump status
        status_frame = ttk.LabelFrame(overview_frame, text="System Status")
        status_frame.pack(fill=tk.X, padx=5, pady=5)
        
        # Flow rates
        flow_frame = ttk.Frame(status_frame)
        flow_frame.pack(side=tk.LEFT, padx=20, pady=5)
        
        ttk.Label(flow_frame, text="Flow Rates:").pack()
        self.flow1_label = ttk.Label(flow_frame, text="Flow 1: 0.0 GPM")
        self.flow1_label.pack()
        self.flow2_label = ttk.Label(flow_frame, text="Flow 2: 0.0 GPM")
        self.flow2_label.pack()
        
        # Pump status
        pump_frame = ttk.Frame(status_frame)
        pump_frame.pack(side=tk.LEFT, padx=20, pady=5)
        
        ttk.Label(pump_frame, text="Pumps:").pack()
        self.pump1_label = ttk.Label(pump_frame, text="Pump 1: OFF", foreground="red")
        self.pump1_label.pack()
        self.pump2_label = ttk.Label(pump_frame, text="Pump 2: OFF", foreground="red")
        self.pump2_label.pack()
        
        # System mode
        mode_frame = ttk.Frame(status_frame)
        mode_frame.pack(side=tk.LEFT, padx=20, pady=5)
        
        ttk.Label(mode_frame, text="System Mode:").pack()
        self.mode_label = ttk.Label(mode_frame, text="OFF", font=("Arial", 12, "bold"))
        self.mode_label.pack()
    
    def create_controls_tab(self, notebook):
        """Create controls tab"""
        controls_frame = ttk.Frame(notebook)
        notebook.add(controls_frame, text="Manual Controls")
        
        # Pump controls
        pump_frame = ttk.LabelFrame(controls_frame, text="Pump Controls")
        pump_frame.pack(fill=tk.X, padx=5, pady=5)
        
        pump1_frame = ttk.Frame(pump_frame)
        pump1_frame.pack(side=tk.LEFT, padx=20, pady=10)
        
        ttk.Label(pump1_frame, text="Pump 1:").pack()
        ttk.Button(pump1_frame, text="START", command=lambda: self.control_pump(1, True)).pack(side=tk.LEFT, padx=5)
        ttk.Button(pump1_frame, text="STOP", command=lambda: self.control_pump(1, False)).pack(side=tk.LEFT, padx=5)
        
        pump2_frame = ttk.Frame(pump_frame)
        pump2_frame.pack(side=tk.LEFT, padx=20, pady=10)
        
        ttk.Label(pump2_frame, text="Pump 2:").pack()
        ttk.Button(pump2_frame, text="START", command=lambda: self.control_pump(2, True)).pack(side=tk.LEFT, padx=5)
        ttk.Button(pump2_frame, text="STOP", command=lambda: self.control_pump(2, False)).pack(side=tk.LEFT, padx=5)
        
        # Valve controls
        valve_frame = ttk.LabelFrame(controls_frame, text="Fill Valve Controls")
        valve_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.valve_buttons = []
        for i in range(9):
            row = i // 3
            col = i % 3
            
            tank_valve_frame = ttk.LabelFrame(valve_frame, text=f"Tank {i+1} Valve")
            tank_valve_frame.grid(row=row, column=col, padx=5, pady=5, sticky="ew")
            
            open_btn = ttk.Button(tank_valve_frame, text="OPEN", 
                                command=lambda t=i: self.control_valve(t, True))
            open_btn.pack(side=tk.LEFT, padx=5, pady=5)
            
            close_btn = ttk.Button(tank_valve_frame, text="CLOSE",
                                 command=lambda t=i: self.control_valve(t, False))
            close_btn.pack(side=tk.LEFT, padx=5, pady=5)
            
            self.valve_buttons.append((open_btn, close_btn))
        
        # Configure grid
        for i in range(3):
            valve_frame.columnconfigure(i, weight=1)
        
        # Emergency stop
        emergency_frame = ttk.LabelFrame(controls_frame, text="Emergency Controls")
        emergency_frame.pack(fill=tk.X, padx=5, pady=5)
        
        emergency_btn = ttk.Button(emergency_frame, text="EMERGENCY STOP", 
                                 command=self.emergency_stop)
        emergency_btn.pack(pady=10)
    
    def create_diagnostics_tab(self, notebook):
        """Create diagnostics tab"""
        diag_frame = ttk.Frame(notebook)
        notebook.add(diag_frame, text="Diagnostics")
        
        # Connection controls
        conn_frame = ttk.LabelFrame(diag_frame, text="Connection Control")
        conn_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Button(conn_frame, text="Connect", command=self.manual_connect).pack(side=tk.LEFT, padx=5, pady=5)
        ttk.Button(conn_frame, text="Disconnect", command=self.manual_disconnect).pack(side=tk.LEFT, padx=5, pady=5)
        ttk.Button(conn_frame, text="Test Connection", command=self.test_connection).pack(side=tk.LEFT, padx=5, pady=5)
        
        # Configuration
        config_frame = ttk.LabelFrame(diag_frame, text="PLC Configuration")
        config_frame.pack(fill=tk.X, padx=5, pady=5)
        
        ttk.Label(config_frame, text="PLC IP:").pack(side=tk.LEFT, padx=5)
        self.ip_entry = ttk.Entry(config_frame, width=15)
        self.ip_entry.pack(side=tk.LEFT, padx=5)
        self.ip_entry.insert(0, self.PLC_IP)
        
        ttk.Label(config_frame, text="Port:").pack(side=tk.LEFT, padx=5)
        self.port_entry = ttk.Entry(config_frame, width=8)
        self.port_entry.pack(side=tk.LEFT, padx=5)
        self.port_entry.insert(0, str(self.PLC_PORT))
        
        ttk.Button(config_frame, text="Update", command=self.update_config).pack(side=tk.LEFT, padx=10)
        
        # Log display
        log_frame = ttk.LabelFrame(diag_frame, text="System Log")
        log_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.log_text = tk.Text(log_frame, height=15, wrap=tk.WORD)
        self.log_text.pack(fill=tk.BOTH, expand=True, side=tk.LEFT)
        
        log_scroll = ttk.Scrollbar(log_frame, orient=tk.VERTICAL, command=self.log_text.yview)
        log_scroll.pack(side=tk.RIGHT, fill=tk.Y)
        self.log_text.config(yscrollcommand=log_scroll.set)
        
        # Add some initial log entries
        self.log_message("Standalone HMI started")
        self.log_message(f"Target PLC: {self.PLC_IP}:{self.PLC_PORT}")
    
    def create_status_bar(self):
        """Create status bar at bottom"""
        self.status_bar = ttk.Frame(self.root)
        self.status_bar.pack(side=tk.BOTTOM, fill=tk.X)
        
        self.status_label = ttk.Label(self.status_bar, text="Ready")
        self.status_label.pack(side=tk.LEFT, padx=5)
        
        self.time_label = ttk.Label(self.status_bar, text="")
        self.time_label.pack(side=tk.RIGHT, padx=5)
    
    def start_data_polling(self):
        """Start background data polling thread"""
        self.data_thread = threading.Thread(target=self.data_polling_loop, daemon=True)
        self.data_thread.start()
    
    def data_polling_loop(self):
        """Main data polling loop"""
        while self.running:
            try:
                if not self.connected:
                    if self.client.connect():
                        self.connected = True
                        self.log_message("Connected to PLC")
                
                if self.connected:
                    success = self.read_plc_data()
                    if success:
                        self.connection_quality = min(100, self.connection_quality + 5)
                        self.last_update = time.time()
                    else:
                        self.connection_quality = max(0, self.connection_quality - 10)
                        if self.connection_quality == 0:
                            self.connected = False
                            self.client.disconnect()
                            self.log_message("Lost connection to PLC")
                
            except Exception as e:
                logger.error(f"Data polling error: {e}")
                self.connected = False
                self.client.disconnect()
            
            time.sleep(self.POLLING_INTERVAL)
    
    def read_plc_data(self):
        """Read data from PLC"""
        try:
            # Read holding registers (tank levels, flows, etc.)
            holding_regs = self.client.read_holding_registers(0, 26)
            if holding_regs:
                # Tank levels (0-8)
                for i in range(9):
                    if i < len(holding_regs):
                        self.tank_levels[i] = holding_regs[i] / 100.0
                
                # Flow rates (10-11)
                if len(holding_regs) > 11:
                    self.flow_rates[0] = holding_regs[10] / 100.0
                    self.flow_rates[1] = holding_regs[11] / 100.0
                
                # Pump runtimes (22-23)
                if len(holding_regs) > 23:
                    self.pump_runtimes[0] = holding_regs[22]
                    self.pump_runtimes[1] = holding_regs[23]
            
            # Read coils (pump/valve states)
            coils = self.client.read_coils(0, 20)
            if coils:
                # Valve states (0-8)
                for i in range(9):
                    if i < len(coils):
                        self.valve_states[i] = coils[i]
                
                # Pump states (10-11)
                if len(coils) > 11:
                    self.pump_states[0] = coils[10]
                    self.pump_states[1] = coils[11]
            
            # Read discrete inputs (alarms)
            inputs = self.client.read_discrete_inputs(0, 25)
            if inputs:
                # HH alarms (0-8)
                for i in range(9):
                    if i < len(inputs):
                        self.hh_alarms[i] = inputs[i]
                
                # Main EPO (20)
                if len(inputs) > 20:
                    self.main_epo = inputs[20]
            
            return True
            
        except Exception as e:
            logger.error(f"Error reading PLC data: {e}")
            return False
    
    def control_pump(self, pump_id, state):
        """Control pump operation"""
        try:
            if not self.connected:
                self.log_message("Error: Not connected to PLC")
                return
            
            coil_address = 10 if pump_id == 1 else 11
            success = self.client.write_single_coil(coil_address, state)
            
            if success:
                self.log_message(f"Pump {pump_id} {'started' if state else 'stopped'}")
            else:
                self.log_message(f"Failed to control pump {pump_id}")
                
        except Exception as e:
            self.log_message(f"Error controlling pump {pump_id}: {e}")
    
    def control_valve(self, tank_id, state):
        """Control valve operation"""
        try:
            if not self.connected:
                self.log_message("Error: Not connected to PLC")
                return
            
            success = self.client.write_single_coil(tank_id, state)
            
            if success:
                self.log_message(f"Tank {tank_id+1} valve {'opened' if state else 'closed'}")
            else:
                self.log_message(f"Failed to control tank {tank_id+1} valve")
                
        except Exception as e:
            self.log_message(f"Error controlling valve: {e}")
    
    def emergency_stop(self):
        """Emergency stop all operations"""
        if not messagebox.askyesno("Emergency Stop", 
                                  "EMERGENCY STOP - This will shut down all pumps and close all valves. Continue?"):
            return
        
        try:
            if not self.connected:
                self.log_message("Error: Not connected to PLC")
                return
            
            success_count = 0
            
            # Stop all pumps
            for pump_id in [1, 2]:
                coil_address = 10 if pump_id == 1 else 11
                if self.client.write_single_coil(coil_address, False):
                    success_count += 1
            
            # Close all valves
            for tank_id in range(9):
                if self.client.write_single_coil(tank_id, False):
                    success_count += 1
            
            self.log_message(f"EMERGENCY STOP executed - {success_count} operations successful")
            
        except Exception as e:
            self.log_message(f"Emergency stop error: {e}")
    
    def manual_connect(self):
        """Manual connection attempt"""
        if self.client.connect():
            self.connected = True
            self.log_message("Manual connection successful")
        else:
            self.log_message("Manual connection failed")
    
    def manual_disconnect(self):
        """Manual disconnect"""
        self.client.disconnect()
        self.connected = False
        self.log_message("Manually disconnected")
    
    def test_connection(self):
        """Test PLC connection"""
        self.log_message("Testing connection...")
        
        # Test socket connection
        try:
            test_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            test_sock.settimeout(3)
            result = test_sock.connect_ex((self.PLC_IP, self.PLC_PORT))
            test_sock.close()
            
            if result == 0:
                self.log_message(f"Network connection to {self.PLC_IP}:{self.PLC_PORT} successful")
                
                # Test Modbus read
                if self.client.connect():
                    test_data = self.client.read_holding_registers(0, 1)
                    if test_data:
                        self.log_message("Modbus communication test successful")
                    else:
                        self.log_message("Modbus communication test failed")
                    self.client.disconnect()
                else:
                    self.log_message("Modbus connection test failed")
            else:
                self.log_message(f"Network connection to {self.PLC_IP}:{self.PLC_PORT} failed")
                
        except Exception as e:
            self.log_message(f"Connection test error: {e}")
    
    def update_config(self):
        """Update PLC configuration"""
        try:
            new_ip = self.ip_entry.get().strip()
            new_port = int(self.port_entry.get().strip())
            
            if new_ip != self.PLC_IP or new_port != self.PLC_PORT:
                # Disconnect first
                self.client.disconnect()
                self.connected = False
                
                # Update configuration
                self.PLC_IP = new_ip
                self.PLC_PORT = new_port
                self.client = ModbusTCPClient(self.PLC_IP, self.PLC_PORT, self.UNIT_ID)
                
                self.log_message(f"Configuration updated: {self.PLC_IP}:{self.PLC_PORT}")
                
        except ValueError:
            self.log_message("Invalid port number")
        except Exception as e:
            self.log_message(f"Configuration update error: {e}")
    
    def update_display(self):
        """Update GUI display"""
        try:
            # Update connection status
            if self.connected:
                self.conn_status_label.config(text="Connected", foreground="green")
            else:
                self.conn_status_label.config(text="Disconnected", foreground="red")
            
            self.quality_label.config(text=f"Quality: {self.connection_quality}%")
            
            if self.last_update > 0:
                age = int(time.time() - self.last_update)
                self.last_update_label.config(text=f"Last Update: {age}s ago")
            else:
                self.last_update_label.config(text="Last Update: Never")
            
            # Update tank displays
            for i in range(9):
                level = self.tank_levels[i]
                self.tank_labels[i].config(text=f"{level:.1f}%")
                self.level_bars[i]['value'] = level
                
                # Color based on level
                if level > 90:
                    color = "red"
                elif level > 75:
                    color = "orange"
                else:
                    color = "blue"
                
                # Update alarm status
                if hasattr(self, 'tank_frames'):
                    alarm_widgets = [w for w in self.tank_frames[i].winfo_children() if isinstance(w, ttk.Label)]
                    if len(alarm_widgets) >= 2:
                        if self.hh_alarms[i]:
                            alarm_widgets[-1].config(text="ALARM", foreground="red")
                        else:
                            alarm_widgets[-1].config(text="OK", foreground="green")
            
            # Update flow rates
            self.flow1_label.config(text=f"Flow 1: {self.flow_rates[0]:.1f} GPM")
            self.flow2_label.config(text=f"Flow 2: {self.flow_rates[1]:.1f} GPM")
            
            # Update pump status
            pump1_color = "green" if self.pump_states[0] else "red"
            pump1_text = "ON" if self.pump_states[0] else "OFF"
            self.pump1_label.config(text=f"Pump 1: {pump1_text}", foreground=pump1_color)
            
            pump2_color = "green" if self.pump_states[1] else "red"
            pump2_text = "ON" if self.pump_states[1] else "OFF"
            self.pump2_label.config(text=f"Pump 2: {pump2_text}", foreground=pump2_color)
            
            # Update system mode
            mode_names = ["OFF", "MANUAL", "AUTO"]
            mode_text = mode_names[self.system_mode] if self.system_mode < len(mode_names) else "UNKNOWN"
            self.mode_label.config(text=mode_text)
            
            # Update status bar
            self.time_label.config(text=datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
            
            if self.connected:
                self.status_label.config(text=f"Connected to {self.PLC_IP} - Quality: {self.connection_quality}%")
            else:
                self.status_label.config(text=f"Disconnected from {self.PLC_IP}")
            
        except Exception as e:
            logger.error(f"Display update error: {e}")
        
        # Schedule next update
        self.root.after(1000, self.update_display)
    
    def log_message(self, message):
        """Add message to log display"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        log_entry = f"[{timestamp}] {message}\n"
        
        try:
            self.log_text.insert(tk.END, log_entry)
            self.log_text.see(tk.END)
            
            # Limit log size
            lines = int(self.log_text.index('end-1c').split('.')[0])
            if lines > 1000:
                self.log_text.delete(1.0, f"{lines-800}.0")
        except:
            pass
        
        # Also log to file
        logger.info(message)
    
    def on_closing(self):
        """Handle window closing"""
        self.running = False
        if self.client:
            self.client.disconnect()
        self.root.destroy()
    
    def run(self):
        """Start the application"""
        self.root.mainloop()

def main():
    """Main entry point"""
    print("=" * 60)
    print("STANDALONE TANK LEVEL CONTROL HMI")
    print("No external dependencies - works on air-gapped systems")
    print("=" * 60)
    print("Features:")
    print("  • Real-time tank level monitoring")
    print("  • Manual pump and valve controls") 
    print("  • Built-in Modbus TCP client")
    print("  • Connection diagnostics")
    print("  • Emergency stop functionality")
    print("=" * 60)
    
    try:
        app = StandaloneHMI()
        app.run()
    except KeyboardInterrupt:
        print("\nApplication stopped by user")
    except Exception as e:
        print(f"Application error: {e}")
        logger.exception("Application error")

if __name__ == "__main__":
    main()
